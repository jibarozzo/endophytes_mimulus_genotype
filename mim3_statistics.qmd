---
title: "Mim2_Statistical_analyses"
author: "Bolívar Aponte Rolón"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(out.width ='70%', fig_align = 'center', echo = TRUE, collapse = TRUE, eval=FALSE)
```

## Packages

```{r}
# Core packages
library("tidyverse")
library("data.table")
library("ggpubr")
library("ggfortify")
library("rstatix")
library("broom")
library("readxl")

# Linear Models
library("car")
library("nlme")
library("MASS")
library("MuMIn")
library("sjPlot")
library("class")
#library("caret")

# Community Diversity
library("vegan")
library("hillR")
library("geosphere")
library("indicspecies")

# ggplot2 extensions
library("ggtext")
library("ggpmisc")
library("MetBrewer")

# Tables
library("huxtable")
library("flextable")
library("broom.mixed")
library("officer")
library("knitr")

# Phyloseq friendly
#Some of these are redundant and have conflicts, but have functions that I like better than others or compliment each other.
library("phyloseq")
library("microeco") # New package for microbial analyses
library("file2meco") # File to microeco (phyloseq friendly)
library("metagMisc") # Miscellaneous functions
library("microbiome") # Expands phyloseq 
library("mirlyn")

# Parallel processing
library("parallelly")

# Misc
library("conflicted")
conflict_prefer("select", "dplyr")
conflict_prefer("desc", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("alpha", "ggplot2")
```

# File Path

```{r}
#| echo: false
#| eval: true
#| tidy: true
path <- "../mim3_bioinformatics" # Change accordingly
```

# Objective of the notebook

The goal of this notebook is to explore how endophytes differ in *Mimulus* in a reciprocal transplant experiment in Yosemite National Park. The code here can be at times messy and not well organized. The manuscript document has all the refined code for plots and analyses. I try to keep both documents as similar as possible, but the manuscript document is the final product. Here you may find violin plots and the manuscript boxplots, things like that.

# Data sets

## Cleaning and Shaping

This section cleans and shapes the raw data into two main data frames: `leaf_traits` and `plant_traits`. The first has all data point for leaf trait measurements at the leaf level (raw) and the second one represents the average per plant while incorporating FEF community data. The FEF community data is only available for 287 samples.This is important for the rarefaction of sequence dept and later on in the `asv_matrix` that gives way for community analyses in [Community Diversity]. I include a custom function for p-value formatting.

### Raw data sets

```{r, cleaning_chaping_data}
#| echo: false
#| eval: true
#| tidy: true

################################
########## RAW data sets #######
################################

traits <- read_excel(file.path(path, "field_data/Mimulus_CH3_Endophytes_ReciprocalTransplant_2023.xlsx"), sheet = "CH3_Leaf_traits") # Main raw data set
imagej <- read_excel(file.path(path, "field_data/Mimulus_CH3_ImageJ_Data.xlsx"), sheet = "All_Site_ImageJ_Preliminary")  |># ImageJ data set
  distinct(Unique_ID, .keep_all = T) # Removing duplicates


# Cleaning and transforming data
# I suspect variables are not-normally distributed given work on Mim2. I proceed with a log transformation of the data.
# Leaf traits transformed
# Leaf level data set
leaf_traits <-
  left_join(
    traits,
    select(imagej, Unique_ID, ImageJ_1, ImageJ_2, Leaf_Lobe_Index),
    join_by(Unique_ID)
  ) |>
  select(-Notes) |>
  mutate(
    Habitat = case_match(Site, "LM" ~ "Meadow 1",
                         "CF" ~ "Meadow 2",
                         "OPN" ~ "Granite 1"),
    Genotype = case_match(Genotype, "F2WY" ~ "F2LG",  # Re-coded on 07/17/2024 -BAR
                          "F2YW" ~ "F2GL",
                          "L" ~ "L",
                          "G" ~ "G"),
    logLBI = log10(Leaf_Lobe_Index),
    logACI = log10(ACI),
    logLT = log10(Leaf_thickness),
    logLPS = log10(Leaf_toughness),
    logLMA = log10(LMA)
  ) |>
  relocate(Habitat, .after = Site)

# Setting levels for plotting purposes
leaf_traits$Site <- factor(leaf_traits$Site, levels = c("LM", "CF", "OPN")) 
leaf_traits$Habitat <- factor(leaf_traits$Habitat, levels = c("Meadow 1", "Meadow 2", "Granite 1"))

# Matching pooled samples (e.g., CF_23_L_POOL) with original name
# M. guttatus and M. laciniatus parentals

pooled_parental <- leaf_traits |>
  filter(Genotype == c("L", "G")) |>
  group_by(Site, Block, Genotype) |>
  unite(Unique_ID, c(Site, Block, Genotype), sep = "_", remove = FALSE) |>
  mutate(Unique_ID = paste(Unique_ID, "_POOL", sep = ""))

#Plant level for ASV analyses
# Bind parental pools to F2 hybrids
# Log transformed
plant_traits <- leaf_traits |>
    bind_rows(pooled_parental) |> # Adding pooled samples. Samples that are part of the pool are still present. 
  group_by(Unique_ID, Site, Habitat, Block, Genotype)|>
  filter(!Site == "YCN") |> # Removing YCN site
  summarise(ACI = mean(ACI, na.rm = TRUE),
            LT = mean(Leaf_thickness, na.rm = TRUE),
            LPS= mean(Leaf_toughness, na.rm =TRUE),
            LMA = mean(LMA, na.rm = TRUE),
            ImageJ_1 = mean(ImageJ_1, na.rm = TRUE),
            ImageJ_2 = mean(ImageJ_2, na.rm = TRUE),
            LBI = mean(Leaf_Lobe_Index, na.rm = TRUE)) |>
  mutate(Site = as.factor(Site),
         Habitat = as.factor(Habitat),
         Block = as.factor(Block), 
         Genotype = as.factor(Genotype),
         logLBI = log10(LBI),
         logACI = log10(ACI),
         logLT = log10(LT),
         logLPS = log10(LPS),
         logLMA = log10(LMA)) 

# Setting levels for plotting purposes
plant_traits$Site <- factor(plant_traits$Site, levels = c("LM", "CF", "OPN")) 
plant_traits$Habitat <- factor(plant_traits$Habitat, levels = c("Meadow 1", "Meadow 2", "Granite 1"))

# Save file
# Leaf traits
 saveRDS(leaf_traits, file.path(path, "clean_data/statistics/leaf_traits.rds"))

# Plant traits WITHOUT community data
 saveRDS(plant_traits, file.path(path, "clean_data/statistics/plant_traits.rds"))
```

Variables ACI and leaf toughness show up a logical. There must be a character or something in the raw data that is causing this. I will ignore this for now. 04/03/2024.

For purposes of ease fo plotting, the `Genotype` variable was recoded to `F2LG`, `F2GL`, `L`, and `G`. This is to make the plot labels more informative as to what species are being compared. The `Unique_ID` variable still retains the WY and YW nomenclature.

### Phyloseq, mirl, and meco objects

```{r, phylo_objects}
###################################
#### Load Phyloseq objects ########
###################################
#Phyloseq joins various objects that we have already prepare: taxonomic table, ASV table and our sample data. These are the data frames resulting from the phyloseq section in mim3_bioinformatics.qmd notebook.

# Load Phyloseq object cleaned of singletons (532 ASVs)

# Update of Genotype variable 07/17/2024 -BAR
# ps_clean_3@sam_data <- plant_traits |>
#   filter(Unique_ID %in% names_list) |> # names_list is from the ASV table/matrix
#   as.data.frame() |>
#   column_to_rownames(var = "Unique_ID") |>
#   sample_data()
# 
# saveRDS(ps_clean_3, file.path(path, "clean_data/taxonomy/ASV_8859_v2_phyloseq_nonsingletons.rds"))

ps_clean_3 <- readRDS(file.path(path, "clean_data/taxonomy/ASV_8859_v2_phyloseq_nonsingletons.rds"))

#ps_clean_3_df  <- read.csv(file.path(path, "clean_data/taxonomy/ASV_8859_v2_phyloseq_nonsingletons.csv"))
pseq_rrfa <- readRDS(file.path(path, "clean_data/statistics/pseq_rrfa.rds")) #Mirlyn object
rarefied_phyloseq <- readRDS(file.path(path, "clean_data/statistics/rarefied_phyloseq.rds"))



```

### Leaf traits with community data

```{r}
#### Leaf traits with community data ####
# Calculating Hill orders on non-rarefied data
# The estimate_richness() is meant to be used with untrimmed data. It is highly dependnet on singletons. My data is already trimmed and decontaminated. My singleton "removal" eliminates ASVs with all zeros or samples wil all zeros. Singletons do remain, so this is not a problem.
plant_traits <- ps_clean_3 |> #Estimating community richness and shannon diversity from phyloseq object
  estimate_richness(split = TRUE, measures = c("Observed","Shannon", "Simpson")) |>
       #  Simpson = 1 / Simpson) |>
  mutate(hill_1 = exp(Shannon), #Observed column is equivalent to hill_0
         hill_2 = 1/(1 - Simpson)) |> #Simpson index is (1-D) and InvSimpson (1/D) which is equivalent to hill_2
  rownames_to_column() |>
  rename(Unique_ID = rowname) |>
  right_join(plant_traits, by = "Unique_ID") |>
  relocate(Observed, 
           Shannon, 
           Simpson, 
           hill_1,
           hill_2,
           .after = logLMA) |>
  rename(Simpson_1minusD = Simpson)


# See https://www.jak.bio/posts/me/20211227_simpson/simpson_diversity.html for a good explanation of Simpson's diversity index.


##########################################################
############### Save files after changes #################
##########################################################
# Save file
# Leaf traits
 saveRDS(leaf_traits, file.path(path, "clean_data/statistics/leaf_traits.rds"))
 write.csv(leaf_traits, file.path(path, "clean_data/statistics/leaf_traits.csv"))
# 
# # Plant traits with community data
 saveRDS(plant_traits, file.path(path, "clean_data/statistics/plant_traits.rds"))
 write.csv(plant_traits, file.path(path, "clean_data/statistics/plant_traits.csv"))
```

### Load files

```{r}
#####################################################
############### Load master files here ##############
#####################################################
leaf_traits <- readRDS(file.path(path, "clean_data/statistics/leaf_traits.rds")) # Post all the processing aboove, lod from here.
plant_traits <- readRDS(file.path(path, "clean_data/statistics/plant_traits.rds"))

# Functions
source("functions/alpha_rfy.R")
source("functions/pval_format.R")

# Comparisons
my_comparisons <- list(
  c("F2LG", "L"),
  c("F2LG", "G"),
  c("F2GL", "L"),
  c("F2GL", "G"),
  c("G", "L"),
  c("F2GL", "F2LG")
)
my_comparisons2 <- list(c("CF", "LM"), c("CF", "OPN"), c("LM", "OPN"))

# List of ASV samples
names_list <- colnames(ps_clean_3@otu_table) #List of samples
```

## Descriptive stats

From previous experience in MIM2 project, I know the data is not normally distributed, thus transformed in previous sections. I will focus on LBI for this project. Other traits have a lot of missing data or have a character that causes them to be interpreted as logical.

```{r, Leaf_traits_basics}
#| echo: false
#| eval: true
#| tidy: true
# Sites and Species sampled
leaf_traits |>
  group_by(Site,Genotype) |>
  summarise(n = as.integer(n()/3))|> # Dividing by 3 due to replicate measurements of each sample
  pivot_wider(names_from = Genotype, values_from = n)|>
  knitr::kable(caption = "Number of samples per population/site and species.")

#LBI
hist(leaf_traits$Leaf_Lobe_Index) #Skewed to the left, non-normal distribution of LBI data
mean(leaf_traits$Leaf_Lobe_Index, na.rm = TRUE)
max(leaf_traits$Leaf_Lobe_Index, na.rm = TRUE)
min(leaf_traits$Leaf_Lobe_Index, na.rm = TRUE)
sd(leaf_traits$Leaf_Lobe_Index, na.rm = TRUE)

qqPlot(leaf_traits$Leaf_Lobe_Index) #Does not seem normal at all.
hist(rnorm(n = length(leaf_traits$Leaf_Lobe_Index))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$Leaf_Lobe_Index) #Since p-value is less than 0.05 this means the residuals from the LBI data are not normally distributed. Data needs transfromation.
fligner.test(logLBI ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#LMA
hist(leaf_traits$LMA)
mean(leaf_traits$LMA, na.rm = TRUE)
max(leaf_traits$LMA, na.rm = TRUE)
min(leaf_traits$LMA, na.rm = TRUE)
sd(leaf_traits$LMA, na.rm = TRUE)

qqPlot(leaf_traits$LMA)
#hist(rnorm(n = length(leaf_traits$LMA))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$LMA) #Since p-value is less than 0.05 this means the residuals from the LMA data are not normally distributed.
fligner.test(LMA ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#Toughness
hist(leaf_traits$Leaf_toughness) 
mean(leaf_traits$Leaf_toughness, na.rm = TRUE)
max(leaf_traits$Leaf_toughness, na.rm = TRUE)
min(leaf_traits$Leaf_toughness, na.rm = TRUE)
sd(leaf_traits$Leaf_toughness, na.rm = TRUE)

qqPlot(leaf_traits$Leaf_toughness) 
hist(rnorm(n = length(leaf_traits$LPS[leaf_traits$LPS < 4]))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$Leaf_toughness) #Since p-value is less than 0.05 this means the residuals from the LPS data are not normally distributed. Data needs transformation.
fligner.test(Leaf_toughness ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#Thickness
hist(leaf_traits$LT)
mean(leaf_traits$LT, na.rm = TRUE)
max(leaf_traits$LT, na.rm = TRUE)
min(leaf_traits$LT, na.rm = TRUE)
sd(leaf_traits$LT, na.rm = TRUE)

qqPlot(leaf_traits$LT) # Skewed to the right. 
hist(rnorm(n = length(leaf_traits$LT))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$LT) #Since p-value is less than 0.05 this means the residuals from the LT data are not normally distributed. Data needs transformation.
fligner.test(LT ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#ACI
hist(leaf_traits$ACI[leaf_traits$ACI < 20]) #Setting cut-off at 20 to remove outliers. 
mean(leaf_traits$ACI[leaf_traits$ACI <20], na.rm = TRUE)
max(leaf_traits$ACI, na.rm = TRUE)
min(leaf_traits$ACI, na.rm = TRUE)
sd(leaf_traits$ACI[leaf_traits$ACI <20], na.rm = TRUE)

qqPlot(leaf_traits$ACI[leaf_traits$ACI <20]) # Remove outliers, it's is skewed to the right. 
hist(rnorm(n = length(leaf_traits$ACI))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$ACI[leaf_traits$ACI <20]) #Since p-value is less than 0.05 this means the residuals from the Thickness data are not normally distributed. Data needs transformation.
fligner.test(ACI ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.

#Elevation_m
hist(leaf_traits$Elevation_m)
mean(leaf_traits$Elevation_m, na.rm = TRUE)
max(leaf_traits$Elevation_m, na.rm = TRUE)
min(leaf_traits$Elevation_m, na.rm = TRUE)
sd(leaf_traits$Elevation_m, na.rm = TRUE)

qqPlot(leaf_traits$Elevation_m) 
hist(rnorm(n = length(leaf_traits$Elevation_m))) #For comparison: normal distribution based on random permutation of my data.
shapiro.test(leaf_traits$Elevation_m) #Since p-value is less than 0.05 this means the residuals from the Thickness data are not normally distributed. Data needs transformation.
fligner.test(Elevation_m ~ Site, data = leaf_traits) #Homogeneity of variances test. p-value < 0.05, variances are not equal.
```

## Post data transformations

```{r, post_transformation}
#| echo: false
#| eval: true
#| tidy: true

#LBI
hist(plant_traits$LBI, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(plant_traits$logLBI), col='coral2', main='Log Transformed')
qqPlot(plant_traits$logLBI) #a BETTER, but not normal distribution
shapiro.test(plant_traits$logLBI)

#LMA
hist(leaf_traits$LMA, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logLMA), col='coral2', main='Log Transformed')
qqPlot(na.omit(leaf_traits$logLMA)) 
shapiro.test(na.omit(leaf_traits$logLMA))

#Toughness
hist(leaf_traits$Toughness[leaf_traits$Toughness < 4], col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logLPS[leaf_traits$logLPS < 0.5]), col='coral2', main='Log Transformed')
qqPlot(leaf_traits$logLPS[leaf_traits$logLPS < 0.5]) # Excludinfg the outliers, this transformation looks good
shapiro.test(leaf_traits$logLPS) # It still does not meet normality assumptions.

#Thickness
hist(leaf_traits$Thickness, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logLT), col='coral2', main='Log Transformed')
qqPlot(leaf_traits$logLT)
shapiro.test(leaf_traits$logLT) #Close to normality, but not quite there.

#ACI
hist(leaf_traits$ACI, col = "steelblue", main = "Non-normal distribution")
hist(na.omit(leaf_traits$logACI), col='coral2', main='Log Transformed')
qqPlot(leaf_traits$logACI) 
shapiro.test(leaf_traits$logACI) #Another transformation that does not meet normality assumptions.
```

The log transformations improve the normality of the data, but it does not meet the assumptions for normality. I will proceed with the analyses using the log transformed data. I will use non-parametric tests for the analyses.

## Non-parametric tests

```{r, non_parametric}
#M1 <- lme(logLBI ~ , method = "REML", data = imagej1) # this is not the best given that I don't have continuous data.

#Kruskal-Wallis
#Because the data does not meet normality assumptions after transformation, I decisded to stick to a non-parametric test like Kruskal-Wallis.
# LBI by Site
print(kruskal.test(logLBI ~ Site, 
                   data = plant_traits,
                   na.action = na.omit))

# LBI by Genotype
print(kruskal.test(logLBI ~ Genotype, 
             data = plant_traits,
             na.action = na.omit))


#Post-Hoc tests
TukeyHSD(two.way, which = "Genotype")
pairwise.wilcox.test(plant_traits$logLBI, g = plant_traits$Site)
pairwise.wilcox.test(plant_traits$logLBI, g = plant_traits$Genotype)
```

# Figures


### Themes

```{r, themes}
#ggplot themes
# Theme for leaf trait and diversity plots: discrete
theme_lfspp_discrete <-      theme_classic(base_size = 16) +
  theme(
    legend.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold"),
    panel.border = element_rect(linetype = "blank", fill = NA),
    legend.text = element_markdown(size = 12),
    plot.caption = element_markdown(size = 12),
    #Make legend text italic
    axis.text.x = element_blank()
  )

# Theme for leaf trait plots: continuous
theme_lfspp_continuous <- theme_classic(base_size = 16) +
  theme(
    legend.title = element_text(face = "bold"),
    panel.border = element_rect(linetype = "blank", fill = NA),
    legend.text = element_markdown(size = 12),
    #Make legend text italic
    axis.text.x = element_text(size = 14),
    legend.position = "bottom"
  )

# Theme for species by diversity  plots: discrete
theme_sppdiv_discrete <-    theme_classic(base_size = 16) +
  theme(
    legend.title = element_text(face = "bold"),
    #strip.text = element_text(face = "italic", size = 14),
    panel.border = element_rect(linetype = "blank", fill = NA),
    #legend.text = element_text(face = "italic", size = 12), #Make legend text italic
    axis.text.x.bottom = element_blank(),
    axis.title.x = element_blank()
  )

theme_div_discrete <-    theme_classic(base_size = 16) +
  theme(
    legend.title = element_text(face = "bold"),
    #strip.text = element_text(face = "italic", size = 14),
    panel.border = element_rect(linetype = "blank", fill = NA),
    axis.text.x.bottom = element_blank(),
    axis.title.x = element_blank()
  )

# Theme for leaf trait and diversity  plots: continuous
theme_lfdiv_continuous <- theme_classic(base_size = 16) +
  theme(
    legend.title = element_text(face = "bold"),
    strip.text = element_text(face = "bold.italic", size = 14),
    panel.border = element_rect(linetype = "blank", fill = NA),
    legend.text = element_markdown(size = 14), #Make legend text italic
    axis.text.x = element_text(size = 14)
  )
```


### Leaf traits

```{r, correlations}
#Barplots with microeco
# Quick addition traits log transformed
ps_clean_3@sam_data <- plant_traits |>
  filter(Unique_ID %in% names_list) |>
  sample_data()

micro_psclean <- phyloseq2meco(ps_clean_3) # First convert phyloseq to meco

t4 <- trans_env$new(dataset = micro_psclean, env_cols = 12) # 12 is the index for logLBI

t4gg <- t4$cal_autocor(group = c("Genotype"), upper = list(continuous = GGally::wrap("cor", method= "spearman"))) + 
  theme(
    legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA)) +
  scale_fill_manual(values = met.brewer("Johnson", n = 4, type = "discrete", direction = c(-1))) +
  scale_color_manual(values = met.brewer("Johnson", n = 4, type = "discrete", direction = c(-1)))
t4gg
#ggplot2::ggsave(file.path(path, "figures/supp_fig1.png") , plot = t4gg, dpi=300, units=c("mm"), width=300, height=300)
```

#### LBI

```{r, lbi_}
#| echo: false
#| eval: true
#| tidy: true
#| label: lbi
#ggpubr package used for comparisons tests
lbi_compare_means <- compare_means(LBI ~ Genotype,
         data = plant_traits,
         group.by = "Site",
         method = "wilcox.test",
         p.adjust.method = "BH",
  paired = FALSE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)

#lbi_compare_means


#Roughly the same outcome as pairwise_t_test.

#Report with `compare_means` because it is easier to plot with `ggpubr` package.
errbar_lims <- group_by(leaf_traits, Genotype) |> 
              summarize(mean = mean(logLBI), se = sd(logLBI)/sqrt(n()), 
                        upper = mean + (2*se), lower = mean - (2*se))

#Comparisons and labels
my_comparisons <- list(c("F2WY", "L"), c("F2WY", "G"), c("F2YW", "L"), c("F2YW", "G"), c("G", "L"), c("F2YW", "F2WY"))
my_comparisons2 <- list(c("CF", "LM"), c("CF", "OPN"), c("LM", "OPN"))
labels_habitat <- c("Meadow 2", "Meadow 1", "Granite 1")
names(labels_habitat) <- c("CF", "LM", "OPN")

lbi <- ggplot(plant_traits, aes(y = logLBI, x = Genotype)) +
  geom_point(
    aes(color = Genotype),
    alpha = 0.2,
    size = 1.7,
    position = position_jitter(w = 0.2)
  ) +
  geom_boxplot(aes(color = Genotype), alpha = 0.5, outlier.alpha = 0.0) +
  scale_color_manual(values = met.brewer(
      "Johnson",
      n = 4,
      type = "discrete",
      direction = 1
    )
  ) +
  scale_fill_manual(values = met.brewer(
    "Johnson",
    n = 4,
    type = "discrete",
    direction = 1
  )) +
  theme_lfspp_discrete +
  labs(y = "log10[LBI (convex_hull - true_area]/convex_hull)]", x = "", caption = "*n* = 793") +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     #label.y = c(0.4, 0.6, 1),
                     label = "p.signif") +
   facet_wrap(~Site, labeller = labeller(Site = labels_habitat)) 

lbi

ggsave(filename = file.path(path, "figures/lbi_boxplot.png"), plot = lbi, dpi=300, units=c("mm"), width=300, height=150)
```

# Community Diversity

Here we are going to explore the relationship between elevation and FEF community composition through richness and species diversity. I have already calculated Hill numbers in \[Cleaning and Shaping data\]. He we create a dissimilarity matrix and calculate the distance between samples. I remove *M. bicolor* (species "B") from the analysis (see \[Cleaning and Shaping data\] for more details). Here we used a classic data frame that stems from `ps_clean_3` object. The matrix calculations can also be achieved using the phyloseq friendly packages: `microbiome`, `metagMisc` and `mirlyn`. First let's look as summary information from our phyloseq object (see also `mim3_bioinformatics.qmd`).

```{r, summary_info}
# How many ASVs per Phyla and reads per sample are there after decontamination?
# Previous exploration of the data is in `mim2_bioinformatics.qmd`

readcount(ps_clean_3) #Read count
phyloseq_summary(ps_clean_3, more_stats = F, long = F) # metagMisc overall summary
summarize_phyloseq(ps_clean_3) #Microbiome package summary

# How many samples with ASVs per phyla are there AFTER decontamination?
percent_phyla_clean <- phyloseq_ntaxa_by_tax(
  ps_clean_3,
  TaxRank = "Phylum",
  relative = F,
  add_meta_data = F
) |>
  as.data.frame() |>
  mutate(sum = sum(N.OTU)) |>
  group_by(Phylum) |>
  summarise(occurance_in_samples = n())# Count the number of ASV per phylum


# Coverage
cover_chao <- phyloseq_coverage(ps_clean_3, correct_singletons = T) #Coverage: Good-Turing frequency estimation (Chiu, Chao 2016)

# Prevalence plot
phyloseq_prevalence_plot(
  ps_clean_3,
  prev.trh = 0.5,
  taxcolor = "Phylum",
  facet = TRUE,
  point_alpha = 0.7,
  showplot = T
)

# Average relative ASVs per host species
ps_average <- phyloseq_average(
  ps_clean_3,
  avg_type = "arithmetic",
  acomp_zero_impute = NULL,
  aldex_samples = 287,
  aldex_denom = "all",
  group = "Genotype",
  drop_group_zero = TRUE,
  verbose = TRUE,
  progress = "text",
)

# Core ASV abundance
core_abundance(
  ps_clean_3@otu_table,
  detection = 0.1/100,
  prevalence = 50/100,
  include.lowest = FALSE
)

# Rare ASVs
rare_abundance(
  ps_clean_3@otu_table,
  detection = 0.1/100,
  prevalence = 50/100,
  include.lowest = FALSE
)
sample_names(ps_clean_3)
# Core taxa
core_tax <- core_members(ps_clean_3, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)

# Subset core taxa information
taxa <- readRDS(file.path(path, "clean_data/taxonomy/assign_tax_8859_v2.rds"))
core_filter <- list("ASV_1", "ASV_2",  "ASV_3",  "ASV_4",  "ASV_5",  "ASV_6",  "ASV_7",  "ASV_8",  "ASV_9",  "ASV_11", "ASV_12", "ASV_14", "ASV_16", "ASV_18", "ASV_19", "ASV_21", "ASV_23", "ASV_27")
core_taxa <- taxa |>
  filter(ASV_ID %in% core_filter)

# Rare taxa
rare_tax <- rare_members(ps_clean_3, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)
```

The core taxa members are "ASV_1", "ASV_2", "ASV_3", "ASV_4", "ASV_5", "ASV_6", "ASV_7", "ASV_8", "ASV_9", "ASV_11", "ASV_12", "ASV_14", "ASV_16", "ASV_18", "ASV_19", "ASV_21", "ASV_23", "ASV_27". Like in MIM2 project, we see *Cladosporium* spp. (ASV_1), *Vishniacozyma victoriae* (ASV_2), and *Cladosporium herbanum* (ASV_27) and. I notice that some ASVs are duplicates. For some reason the dada algorithm identified them as separate, but the taxonomic information is the same. This could be due to child sequences identified in the process. The sample coverage for this NextSeq 150bp PE run was excellent.

# Sampling depth and effort

How to decide sampling depth for rarefaction?

Visual assessment of sampling depth.

```{r, sampling_depth}
# Reads per sample
names_list <- colnames(ps_clean_3@otu_table) #List of samples
reads <- readcount(ps_clean_3) |>  
  as.data.frame() |>
  rownames_to_column(var = "Unique_ID") |>
  rename(n_seqs = "readcount(ps_clean_3)") |>
  right_join(plant_traits, by = "Unique_ID") |>
  filter(Unique_ID %in% names_list) |>
  select(Unique_ID, Site, Genotype, n_seqs)

# Sum of reads per site per genotype
reads_sum <- reads |>
  group_by(Site, Genotype) |>
  filter(Unique_ID %in% names_list) |>
  summarise(n_seqs = sum(n_seqs)) 

# Visualizing the distribution of reads
ggplot(reads, aes(x = n_seqs)) +
  geom_histogram(binwidth = 10000, fill = "grey", color = "black") +
  coord_cartesian(xlim = c(0, 100000)) # Cut-off

ggplot(reads, aes(x = 1, y = n_seqs)) +
  geom_jitter() +
  scale_y_log10()

test <- reads |>
  arrange(n_seqs) |>
  filter(Unique_ID %in% names_list)

ggplot(test, aes(x = 1:nrow(test), y = n_seqs)) +
  geom_line() +
  coord_cartesian(ylim = c(0, 100000)) # Cut-off


# Arrange the samples to see where the big breaks in counts are. 
reads |>
         arrange(n_seqs) |>
  filter(Unique_ID %in% names_list)

#Good's coverage
cover_goods <- ps_clean_3 |>
  psmelt() |>
  rename(Unique_ID = Sample, ASV = OTU) |> #Renaming OTU column
  dplyr::select(c(1:6))|>  
  #select(Unique_ID, sample_Species, ASV, Abundance) |>
  group_by(Unique_ID) |>
  summarise(n_seqs = sum(Abundance),
            n_sing = sum(Abundance == 1),
            goods = 1 - (n_sing/n_seqs)) 
cover_goods|>
  filter(n_seqs > 1300) |> #Filtering samples with more than f000 reads
  ggplot(aes(x= n_seqs,y = goods)) +
  geom_point() # Similar to `phyloseq_coverage` results above but here we know how it is calculated.
          
cover_goods |>
  filter(n_seqs > 1300) |>
  arrange(goods)
```

From the summaries above and graphical evaluation we see that 1) the median read count is 54112 and and mean read count is 70233. Good's coverage shows that all samples are above \~0.99 cover threshold. I can establish a sampling depth of 1300 reads and retain 282 samples.

### Rarefaction and species accumulation curves

I am calculating some curves to see if we have enough sampling effort.

::: callout-note
Rarefaction is subject to debate, see [@mcmurdie2014] and [@cameron2021] for a discussion.
:::

```{r, rarefaction}
# Alpha diversity metrics
set.seed(123)
# Initial matrices, before rarefaction
# ASV abundance matrix
asv_matrix <- as.matrix(otu_table(ps_clean_3)) # Results in 532 x 287 matrix
class(asv_matrix) <- "matrix"
# Vegan
# Rarefaction curve
vegan::rarecurve(
  t(asv_matrix),
  step = 50,
  cex = 0.5,
  xlab = "Sample Size",
  ylab = "Number of ASVs",
  label = FALSE,
  tidy = FALSE
) # rrarefy generates one randomly rarefied community data frame or vector of given sample size.

# Species accumulation curve
accum_curve <- specaccum(t(asv_matrix), 
                         method = "random", 
                         permutations = 1000, 
                         cex = 0.5)

plot(accum_curve, col = "blue", ci = 1, pch = 16, main = "Species Accumulation Curve", xvar = "sites", xlab = "Number of Samples", ylab = "Number of ASVs")
accum_curve
```

It seems we sampled enough, based on the species accumulation curve. The rarefaction curve also shows that species richness is not necessarily increasing with greater sequencing depth. At around 10000 reads, many samples reach about 30-40 ASVs. It looks like there is little correlation between sequencing depth and ASV accumulation. Samples that have a lower number of reads have comparable number of ASV to samples with a large number of reads.

### Rarefaction strategy for alpha diversity

I am following what I did MIM2 project. I manipulated the `alphadiv_DF` to return a data frame with "shannon", "simpson", and "invsimpson" from the `vegan` package. The data frame has diversity measure calculated for each of the iterations of the rarefied data sets. It still contains the previous diversity measures calculated (non-rarefied) in the \[Cleaning and Shaping\] section. joined this data frame with the `plant_traits` data frame to calculate correlations and other analyses. The manipulation of the function was done in the `alpha_rfy.R` file. The function is called `alpha_rfy_DF`. I used ChatGPT to troubleshoot and write the function. It would have taken me a long time to figure out.

I am just going to rarefy the sequences since the samples have good sequencing depth I retain 282 samples after rarefaction.

```{mermaid}
flowchart LR
  A[Hard edge] --> B(Round edge)
  B --> C{Decision}
  C --> D[Result one]
  C --> E[Result two]
```

Let me evaluate how many samples per site we have:

```{r, samples_per_site}
samples_per_site <- reads |>
  group_by(Site) |>
  summarise(n_samples = n()) |>
  arrange(desc(n_samples))
```
We have a good balance of genotypes per site. OPN is the site with the most samples (n = 116), CF has n = 89 and LM n = 82.

#### Rarefaction of sequences \> samples

```{r, rarefaction_sequence}
# Phyloseq friendly packages

# mirlyn package 
#1300 reads
pseq_rrfa <- mirl(
  ps_clean_3,
  libsize = 1300,
  rep = 50,
  set.seed = 443,
  trimOTUs = FALSE,
  replace = FALSE,
  mc.cores = 8
)

saveRDS(pseq_rrfa, file = "clean_data/statistics/pseq_rrfa.rds") # Saving rarefied phyloseq object
pseq_rrfa <- readRDS("clean_data/statistics/pseq_rrfa.rds") # Loading rarefied phyloseq object



###########################
#### Custom functions #####
###########################
#After playing around with these functions I decided to change the `alphadivDF()` function to return a data frame with the alpha diversity indices, similar to how `estimate_richness()` calculates, from rarefied data sets. 
# Data frame with alpha diversity indices calculated from rarefied data sets
source("functions/alpha_rfy.R")
plant_traits_rfy <- alpha_rfy_DF(pseq_rrfa, diversity = c("shannon", "simpson", "invsimpson")) # Alpha diversity indices

final_names_methodA <- sample_names(pseq_rrfa[[1]]) # Sample names

# RAW Preview
ggplot(plant_traits_rfy, aes(x = Genotype, y = shannon_, color = Genotype)) +
  geom_boxplot(alpha = 0.3, size = 0.5) +
  facet_wrap(~Site) +
  theme_classic(base_size = 12)
```

Now let's clean it up, select the randomized subsamples, and start plotting.

##### Rarefied data frame
Function alpha_rfy_DF() return a data frame with rarefied alpha diversity, BUT also rarefied leaf traits. Somehow it randomizes values and we end up with CF_5_4_F2WY matching with genotype G and corresponding data. Here I remove the randomized leaf trait data and assign the correct values to each sample. It needs to be the same for Unique_ID accros rarefied data frames.
```{r, rarefaction_output}
plant_traits_rfy <- plant_traits_rfy |>
  select(c(17:21)) |> # Selecting variables calculated at rarefactions
  mutate(X = Unique_ID,
         Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)"),
         hill_1 = exp(shannon_)) |> # Observed column is equivalent to hill_0
  # Simpson index is (1-D) and InvSimpson (1/D) which is equivalent to hill_2
  relocate(X, Unique_ID, .before = shannon_) |> # Moving Unique_ID to the front
  rename(
    Observed = observed,
    Shannon = shannon_,
    Simpson_1minusD = simpson_,
    hill_2 = invsimpson_
  ) |>
  left_join(plant_traits|>
              select(-c(18:22)), by = "Unique_ID")|> # Joining with plant_traits data frame
  relocate(Observed, Shannon, Simpson_1minusD, hill_1, hill_2, .after = logLMA)



plant_traits_rfy |>
  select(Unique_ID, Site, Genotype) |>
  group_by(Site) |>
  summarise(n = n()/50) # Number of samples per site per species/ 50 data sets

#Saving rarefied data frame
saveRDS(plant_traits_rfy, file = "clean_data/statistics/plant_traits_rarefied.rds") # Saving rarefied data frame
write.csv(plant_traits_rfy, file = "clean_data/statistics/plant_traits_rarefied.csv") # Saving rarefied data frame as csv

#Loading rarefied data frame
plant_traits_rfy <- readRDS("clean_data/statistics/plant_traits_rarefied.rds") # Loading rarefied data frame
```

I now have a data frame with 282 samples with rarefied alpha diversity indices and plant traits. Site counts: OPN n = 111, CF n = 89, LM n = 82. I will use this for downstream analyses. 


::: callout-note
All analyses for alpha and beta diversity below are completed with `plant_traits_rfy` data frame.
:::

### Exploring rarefied data set

```{r, rarefied_data}
#Mirl object to phyloseq
#Taking the mirl object and converting it to a phyloseq object
#Names of samples cleaned an filtered
final_names <- sample_names(pseq_rrfa[[1]]) # Names of samples)

rrfy_asv_table <-
  as.data.frame(t(rep_otu_df(pseq_rrfa))) |> # Rarefied counts
  rownames_to_column("X") |>
  mutate(Unique_ID =  X,
         # Copyin column to new column
         Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)")) |>
  relocate(Unique_ID, .after = X) |>
  left_join(plant_traits, by = "Unique_ID")


#ASV table
ASV <- rrfy_asv_table |>
  column_to_rownames(var = "X") |>
  select(-c(1, 534:554))

ASV <- otu_table(t(ASV), taxa_are_rows = TRUE)
taxa_names(ASV) #Should be ASV_#

#Taxonomixc table
TAXA <- read.csv(file.path(path,"clean_data/taxonomy/ASV_8859_v2_phyloseq_nonsingletons.csv")) # Taxonomic table
TAXA <- TAXA|>
  select(2:9) |>
  column_to_rownames(var = "ASV") |>
  as.matrix() |>
  tax_table()

# Sample data
SAMP <- rrfy_asv_table |>
  select(c(1:2, 535:555)) |>
  as.data.frame() |>
  column_to_rownames(var = "X") |>
  sample_data()

# Rarfefied phyloseq object
rarefied_phyloseq <- phyloseq(ASV, SAMP, TAXA)

saveRDS(rarefied_phyloseq, file.path(path, "clean_data/statistics/rarefied_phyloseq.rds"))



# Rarefied summary 
# Core ASV abundance
core_abundance(
  rarefied_phyloseq@otu_table,
  detection = 0.1 / 100,
  prevalence = 50 / 100,
  include.lowest = FALSE
)

# Rare ASVs
rare_abundance(
  rarefied_phyloseq@otu_table,
  detection = 0.1 / 100,
  prevalence = 50 / 100,
  include.lowest = FALSE
)

# Core taxa
taxa <- readRDS(file.path(out_dir, "clean_data/taxonomy/assign_tax_8859_v2.rds"))
core_tax <- core_members(rarefied_phyloseq, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)

rfy_core_filter <- list("ASV_1",  "ASV_2",  "ASV_3",  "ASV_4",  "ASV_5",  "ASV_6",  "ASV_7",  "ASV_8", "ASV_11", "ASV_12", "ASV_19", "ASV_21", "ASV_23")

core_taxa <- taxa |>
  filter(ASV_ID %in% rfy_core_filter)

# Rare taxa
rare_tax <- rare_members(rarefied_phyloseq, detection = 0.1/100, prevalence = 50/100, include.lowest = FALSE)

```

We see 5 less core taxa members than the none rarefied data set. Bu the main players are there: ASV_1, ASV_2. 

### Dissimilarity and geographic distance matrices

#### Rarefaction strategy for beta diversity

1.  Subset matrix to sample output from alpha diversity rarefaction
    
2.  Hellinger transformation of the ASV matrix and rarefaction
    1.  See here for a [brief discussion.](https://stats.stackexchange.com/questions/594876/should-i-use-hellinger-transformed-species-abundance-data-for-nmds-if-this-is)
    2.  @legendre2001
3.  Bray-Curtis dissimilarity matrix of mean from rarefied datasets.

##### Matrices

```{r, diss_matrix}
#| echo: false
#| eval: true
#| tidy: true
# Simple Matrix
asv_matrix <- otu_table(ps_clean_3) |> # ASV matrix
  as.data.frame() |>
  select(contains(final_names_methodA)) |> # Samples from method B randomization
  as.matrix()

#Hellinger transformation of matrices rarefied to 750 reads
# To be used for dbRDA and adonis2
rrfy_hell_matrix <- decostand(as.matrix(t(rep_otu_df(pseq_rrfa))), MARGIN = 1, method = "hellinger")

# Cleaning row names
rrfy_hell_matrix <- as.data.frame(rrfy_hell_matrix) |>
  rownames_to_column(var = "X") |>
  mutate(Unique_ID =  X,
         # Copying column to new column
         Unique_ID =  str_remove(Unique_ID, "^.*?(_|-)")) |>
  relocate(Unique_ID, .after = X) |>
  left_join(plant_traits |>
              select(-c(Observed:hill_2)), by = "Unique_ID") |> #Dropping alpha diversity measures, since this is for beta diversity
  relocate(c(535:550), .before = ASV_1)

# Save
saveRDS(rrfy_hell_matrix, file = "clean_data/statistics/rrfy_hell_matrix.rds") 

# Load
rrfy_hell_matrix <- readRDS("clean_data/statistics/rrfy_hell_matrix.rds")


# Mean Hellinger transformation of rarefied data sets
# For Mantel tests
set.seed(433)
asv_avgdist <- avgdist(t(asv_matrix),
                       sample = 1300,
                       distfun = vegdist,
                       dmethod = "hellinger", #Transformation, later Bray_Curtis
                       meanfun = mean,
                       iterations = 50) |>
  as.matrix()

# Save
saveRDS(asv_avgdist, file = "clean_data/statistics/asv_avgdist.rds") # Saving rarefied phyloseq object

# Load  
asv_avgdist <- readRDS("clean_data/statistics/asv_avgdist.rds") # Loading rarefied phyloseq object

# Rarefied data frame names
final_names_methodA <- colnames(asv_avgdist) # Rarefied data frame names from avgdist

# Checking if alpha and beta diversity rarefied objects are the same
test <- sample_data(pseq_rrfa[[1]]) |> # Rarefied phyloseq object
  rownames() 
  # arrange() |>
  # as.character()

# Check if the vectors are identical
identical(sort(test), sort(final_names_methodA)) # TRUE

# Adding column and rownames
rownames(asv_avgdist) <- final_names_methodA
colnames(asv_avgdist) <- final_names_methodA

# # Geographical matrix
# geo_distm <- distm(plant_traits |>
#                       filter(Unique_ID %in% final_names_methodB) |>
#                       column_to_rownames(var = "Unique_ID") |>
#                       select(Longitude, Latitude), fun = distVincentyEllipsoid)
#                       
# # Adding column and rownames
# rownames(geo_distm) <- rownames(final_names_methodB)
# colnames(geo_distm) <- rownames(final_names_methodB)
# 
# # Save
# saveRDS(geo_distm, file = "clean_data/statistics/geo_distm.rds") 
# 
# # Load
# geo_distm <- readRDS("clean_data/statistics/geo_distm.rds")
```

#### ASV abundance barplots

```{r, asv_barplot}
#Barplots with microeco
micro_psclean <- phyloseq2meco(ps_clean_3) # First convert phyloseq to meco


t1 <-
  trans_abund$new(
    dataset = micro_psclean,
    taxrank = "Phylum",
    ntaxa = 10
  )
t1gg <-
  t1$plot_bar(
    #ggnested = T,
    #high_level_add_other = TRUE,
    others_color = "grey70",
    facet = c("Habitat", "Genotype"),
    xtext_keep = FALSE,
    legend_text_italic = FALSE,
    color_values = RColorBrewer::brewer.pal(8, "Set3")
  )
t1gg <- t1gg + theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold.italic", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA),
         axis.text.x = element_blank())

t1gg
#ggsave(file.path(path, "figures/figure3.png") , plot = t1gg, dpi=300, units=c("mm"), width=200, height=250)

# rarefied Abundance
micro_rarefied_ps <- phyloseq2meco(rarefied_phyloseq) # First convert phyloseq to meco

r1 <- trans_abund$new(dataset = micro_rarefied_ps, taxrank = "Phylum", ntaxa = 8)
r1gg <- r1$plot_bar(others_color = "grey70", facet = c("Site", "Genotype"), xtext_keep = FALSE, legend_text_italic = FALSE, color_values = RColorBrewer::brewer.pal(8, "Set3"))
r1gg <- r1gg + theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold.italic", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA),
         axis.text.x = element_blank())
r1gg

r2 <- trans_abund$new(dataset = micro_rarefied_ps, taxrank = "Genus", ntaxa = 10)
r2gg <- r2$plot_heatmap(facet = c("Site", "Genotype"), xtext_keep = FALSE, withmargin = FALSE) + theme(legend.title = element_text(face = "bold"),
         strip.text = element_text(face = "bold.italic", size = 12),
         panel.border = element_rect(linetype = "blank", fill = NA),
         axis.text.x = element_blank())

r2gg
```


#### Abundance and Hill number plots

##### Abundance
```{r, abundance_hill}
## Abundance of ASVs per site

ps_melt <- psmelt(ps_clean_3) # Melted phyloseq object

abund_compare_means <- compare_means(Abundance ~ Site,
         data = ps_melt,
         #group.by = "Site",
         method = "wilcox.test",
         p.adjust.method = "BH",
  paired = FALSE,
  alternative = "two.sided", 
  mu = 0, 
  var.equal = FALSE,
  conf.level = 0.95)


abund_plot <- ggplot(data = ps_melt|>
                       group_by(Site, Phylum),
                        aes(x = Phylum, y = Abundance)) +
  geom_point(
    aes(color = Site),
    alpha = 0.2,
    size = 1.7,
    position = position_jitter(w = 0.2)
  ) +
  geom_boxplot(aes(color = Site), alpha = 0.5, outlier.alpha = 0.0) +
 scale_color_manual(
    #labels = c('Crane Flat', 'Little Meadow', 'Olmstead Point'),
    values = met.brewer(
      "Tsimshian",
      n = 9,
      type = "continuous",
      direction = -1
    )
  ) +
  #scale_color_manual(aes(color = "black")) +
  theme_sppdiv_discrete +
  labs(y =  "Abundance", x = "", col = "") +
  #scale_y_log10() +
  guides(color = guide_legend(title = "Site")) +
  #facet_grid(~Site) +
  stat_compare_means(comparisons = my_comparisons2,
                     method = "wilcox.test",
                     label = "p.signif") 
  #facet_wrap(~Phylum)
abund_plot


t1$plot_box(group = "Site", xtext_angle = 30)
```

##### Alpha diversity

```{r, hill_numbers}
# Shannon Diversity or hill number 1
# Three main faceted plots come out of this chunk
############################################
#### Alpha diversity ####
#### At the species level ####
############################################

########## Labels ###########
#Legend title label
legend_title <- "Species"
# Species labels
labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("L", "N", "G")
#############################

# Plot
hill0_species <- ggplot(data = plant_traits_rfy,
                        aes(x = Genotype, y = Observed)) +
  geom_point(
    aes(color = Genotype),
    alpha = 0.2,
    size = 1.7,
    position = position_jitter(w = 0.2)
  ) +
  geom_boxplot(aes(color = Genotype), alpha = 0.5, outlier.alpha = 0.0) +
  scale_color_manual(values = met.brewer(
      "Johnson",
      n = 4,
      type = "discrete",
      direction = 1
    )
  ) +
  scale_fill_manual(values = met.brewer(
    "Johnson",
    n = 4,
    type = "discrete",
    direction = 1
  )) +
  #scale_color_manual(aes(color = "black")) +
  theme_sppdiv_discrete +
  labs(y =  "\U1D492 = 0", x = "", col = "") +
  guides(color = guide_legend(title = "Genotype")) +
  #facet_grid(~Site) +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     label = "p.signif")

hill0_species


# Hill number 1
# Shannon diversity or hill number 1
# Plot
hill1_species <- ggplot(data = plant_traits_rfy,
                        aes(x = Genotype, y = hill_1)) +
  geom_point(
    aes(color = Genotype),
    alpha = 0.2,
    size = 1.7,
    position = position_jitter(w = 0.2)
  ) +
  geom_boxplot(aes(color = Genotype), alpha = 0.5, outlier.alpha = 0.0) +
  scale_color_manual(values = met.brewer(
      "Johnson",
      n = 4,
      type = "discrete",
      direction = 1
    )
  ) +
  scale_fill_manual(values = met.brewer(
    "Johnson",
    n = 4,
    type = "discrete",
    direction = 1
  )) +
  #scale_color_manual(aes(color = "black")) +
  theme_sppdiv_discrete +
  labs(y =  "\U1D492 = 1", x = "", col = "") +
  guides(color = guide_legend(title = "Genotype")) +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     label = "p.signif")
  
hill1_species


# Hill number 2
# Inverse Simpson diversity or hill number 2
hill2_species <- ggplot(data = plant_traits_rfy,
                        aes(x = Genotype, y = hill_2)) +
  geom_point(
    aes(color = Genotype),
    alpha = 0.2,
    size = 1.7,
    position = position_jitter(w = 0.2)
  ) +
  geom_boxplot(aes(color = Genotype), alpha = 0.5, outlier.alpha = 0.0) +
  # geom_crossbar(stat="summary",
  #               fun = median,
  #               fun.max = median,
  #               fun.min = median,
  #               fatten = 2,
  #               width = 0.8,
  #               color="black") +
  scale_color_manual(values = met.brewer(
      "Johnson",
      n = 4,
      type = "discrete",
      direction = 1
    )
  ) +
  scale_fill_manual(values = met.brewer(
    "Johnson",
    n = 4,
    type = "discrete",
    direction = 1
  )) +
  #scale_color_manual(aes(color = "black")) +
  theme_sppdiv_discrete +
  labs(y =  "\U1D492 = 2", x = "", col = "") +
  guides(color = guide_legend(title = "Genotype")) +
  stat_compare_means(comparisons = my_comparisons,
                     method = "wilcox.test",
                     label = "p.signif")
  
hill2_species

# Joined plots
hill_numbers_species <- ggarrange(hill0_species, hill1_species, hill2_species, 
                                  nrow = 1, ncol = 3,
                                  common.legend = TRUE,
                                  labels = c("A", "B", "C"),
                                  legend = "bottom")

hill_numbers_species
#ggsave(filename = file.path(path, "figures/hill_numbers_species.png"), plot = hill_numbers_species, dpi=300, units=c("mm"), width=250, height=275)
```

##### Beta diversity
```{r, beta_hill}
#################################
#### Beta diversity ####
#### Across sites ####
#################################

########## Labels ###########
#Legend title label
legend_title <- "Species"
# Species labels
labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("L", "N", "G")
#############################

# Observed richness
# Hill number 0
hill0_beta <-
  ggplot(plant_traits_rfy, aes(x = Site, y = Observed)) +
  geom_point(
    aes(shape = Genotype, color = Site),
    alpha = 0.5,
    size = 1.7,
    position = position_jitter(w = 0.2)
  )+
  geom_boxplot(aes(color = Site), alpha = 0.5, outlier.alpha = 0.0) +
  scale_color_manual(
    labels = c('Crane Flat', 'Little Meadow', 'Olmstead Point'),
    values = met.brewer(
      "Tsimshian",
      n = 3,
      type = "discrete",
      direction = -1
    )
  ) +
  scale_shape_manual(
    values = c(21:24),
  ) +
  theme_div_discrete +
  scale_x_discrete(labels = c('', '', '', '')) +
  stat_compare_means(comparisons = my_comparisons2,
                     method = "wilcox.test",
                     label = "p.signif") +
  labs(y = "\U1D492 = 0", x = "") +
  guides(fill = guide_legend(title = "Site"),
         shape = guide_legend(title = "Genotype"))

hill0_beta



# Hill number 1
# Shannon diversity or hill number 1
hill1_beta <- ggplot(plant_traits_rfy, aes(x = Site, y = hill_1)) +
  geom_point(
    aes(shape = Genotype, color = Site),
    alpha = 0.5,
    size = 1.7,
    position = position_jitter(w = 0.2)
  )+
  geom_boxplot(aes(color = Site), alpha = 0.5, outlier.alpha = 0.0) +
  scale_color_manual(
    labels = c('Crane Flat', 'Little Meadow', 'Olmstead Point'),
    values = met.brewer(
      "Tsimshian",
      n = 4,
      type = "discrete",
      direction = -1
    )
  ) +
  scale_shape_manual(
    values = c(21:24),
  ) +
  theme_div_discrete +
  scale_x_discrete(labels = c('', '', '', '')) +
  stat_compare_means(comparisons = my_comparisons2,
                     method = "wilcox.test",
                     label = "p.signif") +
  labs(y = "\U1D492 = 1", x = "") +
  guides(fill = guide_legend(title = "Site"),
         shape = guide_legend(title = "Genotype"))

hill1_beta


# Hill number 2
# Inverse Simpson diversity or hill number 2

hill2_beta <- ggplot(plant_traits_rfy, aes(x = Site, y = hill_2)) +
  geom_point(
    aes(shape = Genotype, color = Site),
    alpha = 0.5,
    size = 1.7,
    position = position_jitter(w = 0.2)
  ) +
  geom_boxplot(aes(color = Site), alpha = 0.5, outlier.alpha = 0.0) +
  # geom_crossbar(stat="summary",
  #               fun = mean,
  #               fun.max = mean,
  #               fun.min = mean,
  #               fatten = 2,
  #               width = 0.5,
  #               color="black") +
  scale_color_manual(
    labels = c('Crane Flat', 'Little Meadow', 'Olmstead Point'),
    values = met.brewer(
      "Tsimshian",
      n = 4,
      type = "discrete",
      direction = -1
    )
  ) +
   scale_fill_manual(
    #labels = c('Crane Flat', 'Little Meadow', 'Olmstead Point'),
    values = met.brewer(
      "Tsimshian",
      n = 4,
      type = "discrete",
      direction = -1
    )
  ) +
  scale_shape_manual(
    values = c(0:3),
  ) +
  theme_div_discrete +
  scale_x_discrete(labels = c('', '', '', '')) +
  stat_compare_means(comparisons = my_comparisons2,
                     method = "wilcox.test",
                     label = "p.signif") +
  labs(y = "\U1D492 = 2", x = "") +
  guides(fill = guide_legend(title = "Site"),
         shape = guide_legend(title = "Genotype", alpha = 1))

hill2_beta


# Joining plots
hill_beta <- ggarrange(hill0_beta, hill1_beta, hill2_beta,
          nrow = 1, ncol = 3,
          common.legend = TRUE,
          legend = "bottom",
          labels = c("D", "E", "F"))
hill_beta

#### Alpha and Beta diversity ####
# Joined plots
# A joined plot of joined plots


alpha_beta_diversity <- ggarrange(hill_numbers_species, "", hill_beta,
                          nrow = 3, ncol = 1,
                          common.legend = FALSE,
                          widths = c(1, 0.2, 1),
                          heights = c(1, 0.2, 1),
                          legend = "bottom")

alpha_beta_diversity

#ggsave(filename = file.path(path, "figures/figure3.png"), plot = alpha_beta_diversity, dpi=300, units=c("mm"), width=300, height=275)
```

#### Mantel tests and correlations

```{r, mantel}
#| echo: false
#| eval: true
#| tidy: true
# Prepare the data for correlation plot
# Longer format
asv_long <-  asv_avgdist |>
  as_tibble(rownames = "A") |>
  pivot_longer(-A, names_to = "B", values_to = "bray_diss")

geo_long <- geo_distm |>
  as_tibble(rownames = "A") |>
  pivot_longer(-A, names_to = "B", values_to = "geo_dist")

# Merge the two dataframes
asv_geo_matrix_long <- inner_join(asv_long, geo_long, by = c("A", "B")) |>
  inner_join(plant_traits |>
               dplyr::select(Unique_ID, Site, Species, Elevation_cat), by = c("A" ="Unique_ID"))

# Visualize the correlation
# Species labels
labels_list <- c("M. laciniatus", "M. nasutus", "M. guttatus")
names(labels_list) <- c("M. laciniatus", "M. nasutus", "M. guttatus")

# Correlation ggplot
mantel_test <- ggplot(asv_geo_matrix_long, aes(y = bray_diss, x = geo_dist)) +
  geom_jitter(aes(color = Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  scale_color_manual("Species", labels = c("*M. laciniatus*", "*M. nasutus*", "*M. guttatus*"), 
                      values = met.brewer("Johnson", 
                                          n = 4, 
                                          type = "discrete", direction = c(-1))) + 
   labs(y = "Bray_Curtis dissimilarity", x = "Geographic distance", col = "") + 
   scale_x_continuous(labels = function(x) format(x, scientific = FALSE)) +
  theme_lfspp_continuous +
  facet_wrap(~ Species)

mantel_test

#ggsave(file.path(path, "figures/mantel_test.png") , plot = mantel_test, dpi=300, units=c("mm"), width=200, height=150)

# Mantel test
# All data points
set.seed(859)
abund_geo  <- mantel(asv_avgdist, geo_distm, 
                     method = "spearman", 
                     parallel = 8,
                     permutations = 9999, 
                     na.rm = TRUE)
abund_geo

# Mantel test by species
# M. laciniatus

# Samples with species to subset/filter matrices downstream
# M. laciniatus
lac_names_rfy <- plant_traits |>
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Unique_ID %in% final_names_methodB,
    Species == "M. laciniatus") |>
  pull(Unique_ID) 

# Subset the data
lac_mantel  <- mantel(asv_long |> # Subset the data
                       filter(A %in% lac_names_rfy, B %in% lac_names_rfy) |>
                       pivot_wider(names_from = B, values_from = bray_diss) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                     geo_long |> # Subset the data
                       filter(A %in% lac_names_rfy, B %in% lac_names_rfy) |>
                       pivot_wider(names_from = B, values_from = geo_dist) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                      method = "spearman", permutations = 9999, na.rm = TRUE)
lac_mantel

# M. nasutus
nas_names_rfy <- plant_traits |> 
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Unique_ID %in% final_names_methodB,
         Species == "M. nasutus") |>
  pull(Unique_ID)
nas_mantel  <- mantel(asv_long |> # Subset the data
                       filter(A %in% nas_names_rfy, B %in% nas_names_rfy) |>
                       pivot_wider(names_from = B, values_from = bray_diss) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(), 
                      geo_long |> # Subset the data
                       filter(A %in% nas_names_rfy, B %in% nas_names_rfy) |>
                       pivot_wider(names_from = B, values_from = geo_dist) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(), 
                     method = "spearman", permutations = 9999, na.rm = TRUE)
nas_mantel

# M. guttatus
gut_names_rfy <- plant_traits |> 
  slice(1:157) |> # Only selecting observations with ASV data 
  filter(Unique_ID %in% final_names_methodB,
         Species == "M. guttatus") |>
  pull(Unique_ID)
# Subset the data
gut_mantel  <- mantel(asv_long |> # Subset the data
                       filter(A %in% gut_names_rfy, B %in% gut_names_rfy) |>
                       pivot_wider(names_from = B, values_from = bray_diss) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                     geo_long |> # Subset the data
                       filter(A %in% gut_names_rfy, B %in% gut_names_rfy) |>
                       pivot_wider(names_from = B, values_from = geo_dist) |>
                       column_to_rownames(var = "A") |>
                       as.matrix(),
                     method = "spearman", permutations = 9999, na.rm = TRUE)
gut_mantel
```

The correlation plot for Bray-Curtis dissimilarity and geographical distance shows a positive correlation. The more distant two sites are, the more dissimilar their FEF communities are (bray = 1). The Mantel test shows a significant correlation between the two matrices (r = 0.054, p \< 0.02).

### Communitty simple linear models

```{r, community_lm}
plot_regression(diversity ~ Elevation_m, meta(ps_melt))
plot_frequencies(tax_table(ps_clean_3), "Phylum", "Species")
ps <- add_refseq(ps_clean_3)
print(p)


summarize_phyloseq(ps_clean_3)


# Hill number 0
ggplot(ps_melt, aes(x = Abundance, y = Observed)) +
  geom_jitter(aes(color = sample_Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(y = "𝑞 = 0", x = "Abundance", col = "") +
  theme_classic(base_size = 12) +
  theme(legend.title = element_text(face = "bold"),
        strip.text = element_text(face = "italic", size = 14),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_text(size = 12),
        axis.title.x = element_text(size = 14))

# Hill number 1
# Shannon diversity or hill number 1
ggplot(ps_melt, aes(x = Abundance, y = hill_1)) +
  geom_jitter(aes(color = sample_Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(y = "𝑞 = 1", x = "Abundance", col = "") +
  theme_classic(base_size = 12) +
  theme(legend.title = element_text(face = "bold"),
        strip.text = element_text(face = "italic", size = 14),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_text(size = 12),
        axis.title.x = element_text(size = 14))

# Hill number 2
# Inverse Simpson diversity or hill number 2
ggplot(ps_melt, aes(x = Abundance, y = hill_2)) +
  geom_jitter(aes(color = sample_Species), alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(y = "𝑞 = 2", x = "Abundance", col = "") +
  theme_classic(base_size = 12) +
  theme(legend.title = element_text(face = "bold"),
        strip.text = element_text(face = "italic", size = 14),
        panel.border = element_rect(linetype = "blank", fill = NA),
        legend.text = element_markdown(size = 12), #Make legend text italic
        axis.text.x = element_text(size = 12),
        axis.title.x = element_text(size = 14))


```

### Leaf traits Simple Linear model

Regressions presented at Evo 2023.

```{r}
# Regressions
# Elevation_m and Thicknes
  
t <-ggplot(data = leaf_traits, aes(y= Thickness, x = Elevation_m, color = Species)) +
   geom_jitter(aes(color = Species,), size = 2, alpha = 0.5, na.rm = TRUE)+
#scale_shape_manual(values=c(1:24)) +
  scale_color_manual(values= met.brewer("Johnson", n = 4, type = "discrete"))+
  geom_smooth(method=lm, se = F) +
 # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 700, label.x = 6000, aes(label = ..eq.label..), sep = "~~~~", size = rel(3), color= "black") +
  stat_regline_equation(label.y = 650 , label.x = 6000, aes(label = ..adj.rr.label..), size = rel(3),color = "black") +
  labs(y="Leaf thickness (/u03BCm)", x = "Elevation_m (f.a.s.l.)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
#caption = "**All replicate leaves from tree species included  (n = 210)", col = "Treatment"
t
```

```{r}
# fit <- lm(logit_herbivory ~ Thickness, data = masterant2)
# 
# rSquared <- summary(fit)$r.squared
# rSquared
# anova(fit)
# pVal <- anova(fit)$'Pr(>F)'[1]
# pVal

# Elevation_m and Anthocyanins

a <- ggplot(data = leaf_traits, aes(y= ACI, x= Elevation_m, color = Species))+
   geom_jitter(aes(color = Species), size = 2, alpha = 0.5) +
  #scale_shape_manual(values=c(15:22)) +
  scale_color_manual(values= met.brewer("Johnson", n = 4, type = "discrete")) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 30, label.x = 6000, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 25 , label.x = 6000, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(y="Anthocyanins (ACI)", x="Elevation_m (f.a.s.l.)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title =element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
 
a
#scale_shape_manual(values = c(1:7))
```

```{r}
# Herbivory and leaf thickness

tt <- ggplot(data = masterant2, aes(y= logit_herbivory, x= Thickness, color = E_load))+
   geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 200, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 200, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf thickness (/u03BCm)", y = "logit(Leaf herbivory) (%)") +
 theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none")
tt

# Herbivory and LMA

lma <- ggplot(data = masterant2, aes(y= logit_herbivory, x= LMA, color = E_load))+
  geom_jitter(aes(color = E_load, shape = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
  #stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  stat_regline_equation(label.y = 2.5, label.x = 0.001, aes(label = ..eq.label..), size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 0.001, aes(label = ..adj.rr.label..), size = rel(3), color = "black") +
  labs(x="Leaf mass per area (LMA)", y = "logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
  theme(legend.position="right", legend.title = element_blank(),
        legend.text = element_text(size = 8),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7)) +
  guides(color = "none")  +      #To turn off color legend
  guides(fill = "none") + #To turn off fill legend
  guides(shape = "none") #To turn off shape legend
 
lma

# Herbivory and FEF Shannon Diversity
# Extracting effect size of model to plot
 dv <- ggplot(data = masterant2, aes(y= logit_herbivory, x= Shannon, color = E_load))+
  geom_jitter(aes(color = E_load, color = Species), size = 1.5, alpha = 0.7) +
  scale_shape_manual(values=c(15:22)) +
  geom_smooth(method=lm, se=F) +
 # stat_regline_equation(aes(label = paste(..eq.label.., ..adj.rr.label.., sep = "~~~~"))) +
  geom_smooth(method = lm, se = T , level = 0.95, na.rm = F, color = "black") +
  #scale_fill_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  #scale_color_manual(values= met.brewer("Cross", n = 8, type = "discrete")) +
  stat_regline_equation(label.y = 2.5, label.x = 1.5, aes(label = ..eq.label..),size = rel(3), color= "black") +
  stat_regline_equation(label.y = 2 , label.x = 1.5, aes(label = ..adj.rr.label..), size = rel(3),color = "black") +
  labs(x="Shannon diversity index", y="logit(Leaf herbivory) (%)") +
  theme_minimal(base_size = 10) +
 theme(legend.position="right",
        legend.text = element_text(size = 12),
        axis.text.x=element_text(size = 7),
        axis.text.y=element_text(size = 7))
  # guides(color = "none")  +      #To turn off color legend
  # guides(fill = "none") + #To turn off fill legend
  # guides(shape = "none") #To turn off shape legend
 
 dv

 # Multiples plots together

ant_arranged <- ggarrange(t, tt, a, lma, dv, nrow = 2, ncol=3, common.legend = TRUE, legend="right")


# Adding caption
ant_caption <- "*All individuals per tree species included (n = 210)"
ant_arranged_with_caption <- annotate_figure(ant_arranged, bottom = text_grob(ant_caption), fig.lab.pos = "bottom.right", fig.lab.size = 6)

ant_arranged_with_caption

#ggsave(filename = "./Plots/Aim3_ant_regression_06042023.png", plot = ant_arranged_with_caption, dpi=600, units=c("mm"), width=180, height=140, bg = "white")

```


### dbRDA and PERMDISP modelling


```{r}
################################################################
#### dbRDA modelling for all samples: parentals and hybrids ####
################################################################

# Traits for dbRDA
##### Hellinger transformed rarefied data
# All samples
dbrda_hell_matrix <- rrfy_hell_matrix |>
  column_to_rownames(var = "X") |>
  select(-c(1, 2:17))

saveRDS(dbrda_hell_matrix, file = "clean_data/statistics/dbrda_hell_matrix.rds")
dbrda_hell_matrix <- readRDS("clean_data/statistics/dbrda_hell_matrix.rds")


dbrda_traits <- rrfy_hell_matrix |>
  select(X, Unique_ID, Site, Habitat, Genotype, logLBI) |>
  unite(Habitat_Genotype,
        Habitat,
        Genotype,
        sep = "_",
        remove = FALSE) # To model interactions
saveRDS(dbrda_traits, file = "clean_data/statistics/dbrda_traits.rds")

# Model with intercept only ####
# Using rrfy_hell_matrix as the distance matrix
m0_hell <- dbrda(
  dbrda_hell_matrix ~ 1,
  distance = "bray",
  dfun = vegdist,
  data = dbrda_traits,
  parallel = 20,
  #Passes parallelization to metaMDS function # Do not use when using Rmpi
  na.action = na.omit
) #Model with intercept only.
saveRDS(m0_hell, file = "clean_data/statistics/m0_hell.rds")

m1_hell <- dbrda(
  dbrda_hell_matrix ~ .,
  distance = "bray",
  dfun = vegdist,
  data = dbrda_traits,
  parallel = 20,
  na.action = na.omit
) # Model with all explanatory variables.
saveRDS(m1_hell, file = "clean_data/statistics/m1_hell.rds")

# Model with species, site, leaf traits and elevation. ####
m2_hell <-
  dbrda(
    dbrda_hell_matrix ~ logLBI + Habitat + Genotype,
    distance = "bray",
    dfun = vegdist,
    data = dbrda_traits,
    parallel = 20,
    na.action = na.omit
  )
saveRDS(m2_hell, file = "clean_data/statistics/m2_hell.rds")


#Anovas for m2
#Margins
set.seed(123)
anova_m2_hell_margin <- anova.cca(m2_hell,
                                  by = "margin",
                                  permutations = 999,
                                  parallel = 10)
saveRDS(anova_m2_hell_margin, file = "clean_data/statistics/anova_m2_hell_margin.rds")
anova_m2_hell_margin <- readRDS("clean_data/statistics/anova_m2_hell_margin.rds")

#Terms
set.seed(123)
anova_m2_hell_terms <- anova.cca(m2_hell,
                                 by = "terms",
                                 permutations = 999,
                                 parallel = 10)
saveRDS(anova_m2_hell_terms, file = "clean_data/statistics/anova_m2_hell_terms.rds")
anova_m2_hell_terms <- readRDS("clean_data/statistics/anova_m2_hell_term.rds")

# Model with interactions between site/habitat and genotype
m3_hell <-
  dbrda(
    dbrda_hell_matrix ~ logLBI + Habitat * Genotype,
    distance = "bray",
    dfun = vegdist,
    data = dbrda_traits,
    parallel = 20,
    na.action = na.omit
  )
saveRDS(m3_hell, file = "clean_data/statistics/m3_hell.rds")
m3_hell <- readRDS("clean_data/statistics/m3_hell.rds")

#Anovas for m3
#Margins
set.seed(123)
anova_m3_hell_margin <- anova.cca(m3_hell,
                                  by = "margin",
                                  permutations = 999,
                                  parallel = 10)
saveRDS(anova_m3_hell_margin, file = "clean_data/statistics/anova_m3_hell_margin.rds")
anova_m3_hell_margin <- readRDS("clean_data/statistics/anova_m3_hell_margin.rds")

#Terms
set.seed(123)
anova_m3_hell_term <- anova.cca(m3_hell,
                                by = "terms",
                                permutations = 999,
                                parallel = 10)
saveRDS(anova_m3_hell_term, file = "clean_data/statistics/anova_m3_hell_term.rds")
anova_m3_hell_term <- readRDS("clean_data/statistics/anova_m3_hell_term.rds")

#################################
#### PERMDISP ####
#################################
#Analysis of multivariate homogeneity of group dispersions.

##################################
#### m2_hell model #####
##################################

# By Genotype
set.seed(123)
beta_dis1 <-
  betadisper(
    vegdist(dbrda_hell_matrix, method = "bray"),
    # Matrix of Hellinger transformed data rarefied
    dbrda_traits$Genotype,
    type = "median",
    sqrt.dist = FALSE
  )
saveRDS(beta_dis1, file = "clean_data/statistics/beta_dis1.rds")

anova(beta_dis1)

## Permutest
## Margin
set.seed(123)
beta_perm1_margin <-
  permutest(beta_dis1,
            parallel = 10,
            permutations = 999,
            by = "margin")
saveRDS(beta_perm1_margin, file = "clean_data/statistics/beta_perm1_margin.rds")
beta_perm1_margin <- readRDS("clean_data/statistics/beta_perm1_margin.rds")


## Terms
set.seed(123)
beta_perm1_terms <-
  permutest(beta_dis1,
            parallel = 10,
            permutations = 999,
            by = "terms")
saveRDS(beta_perm1_terms, file = "clean_data/statistics/beta_perm1_terms.rds")
beta_perm1_terms <- readRDS("clean_data/statistics/beta_perm1_terms.rds")

anova(beta_dis1_terms)
TukeyHSD(beta_dis1_terms)

# By Site
set.seed(123)
beta_dis2 <- betadisper(
  vegdist(dbrda_hell_matrix, method = "bray"),
  dbrda_traits$Site,
  type = "median",
  sqrt.dist = FALSE
)
saveRDS(beta_dis2, file = "clean_data/statistics/beta_dis2.rds")

## Permutest
## Margin
set.seed(123)
beta_perm2_margin <-
  permutest(beta_dis2,
            parallel = 10,
            permutations = 999,
            by = "margin")
saveRDS(beta_perm2, file = "clean_data/statistics/beta_perm2_margin.rds")
beta_perm2_margin <- readRDS("clean_data/statistics/beta_perm2_margin.rds")

anova(beta_dis2_margin)
TukeyHSD(beta_dis2_margin)

## Terms
set.seed(123)
beta_perm2_terms <-
  permutest(beta_dis2,
            parallel = 10,
            permutations = 999,
            by = "terms")
saveRDS(beta_perm2_terms, file = "clean_data/statistics/beta_perm2_terms.rds")
beta_perm2_terms <- readRDS("clean_data/statistics/beta_perm2_terms.rds")

anova(beta_dis2_terms)
TukeyHSD(beta_dis2_terms)

##################################
#### m3_hell model #####
##################################

# By Genotype
set.seed(123)
beta_dis3 <-
  betadisper(
    vegdist(dbrda_hell_matrix, method = "bray"),
    # Matrix of Hellinger transformed data rarefied
    dbrda_traits$Genotype,
    type = "median",
    sqrt.dist = FALSE
  )
saveRDS(beta_dis3, file = "clean_data/statistics/beta_dis3.rds")
beta_dis3 <- readRDS("clean_data/statistics/beta_dis3.rds")

boxplot(beta_dis3, main = "Boxplot of beta diversity by Genotype")
anova(beta_dis3)
TukeyHSD(beta_dis3)

## Permutest
## Margin
set.seed(123)
beta_perm3_margin <-
    permutest(beta_dis3,
              parallel = 10,
              permutations = 999,
              by = "margin")
saveRDS(beta_perm3_margin, file = "clean_data/statistics/beta_perm3_margin.rds")
beta_perm3_margin <- readRDS("clean_data/statistics/beta_perm3_margin.rds")

TukeyHSD(beta_perm3_margin)

## Terms
set.seed(123)
beta_perm3_terms <-
    permutest(beta_dis3,
              parallel = 10,
              permutations = 999,
              by = "terms")
saveRDS(beta_perm3_margin, file = "clean_data/statistics/beta_perm3_terms.rds")

# By Habitat
set.seed(123)
beta_dis4 <- betadisper(
  vegdist(dbrda_hell_matrix, method = "bray"),
  dbrda_traits$Habitat,
  type = "median",
  sqrt.dist = FALSE
)
saveRDS(beta_dis4, file = "clean_data/statistics/beta_dis4.rds")
beta_dis4 <- readRDS("clean_data/statistics/beta_dis4.rds")
TukeyHSD(beta_dis4)

## Permutest
set.seed(123)
beta_perm4_margin <-
    permutest(beta_dis4,
              parallel = 10,
              permutations = 999,
              by = "margin")
saveRDS(beta_perm4_margin, file = "clean_data/statistics/beta_perm4_margin.rds")
beta_perm4_margin <- readRDS("clean_data/statistics/beta_perm4_margin.rds")

## Terms
set.seed(123)
beta_perm4_margin <-
    permutest(beta_dis4,
              parallel = 10,
              permutations = 999,
              by = "terms")
saveRDS(beta_perm4_terms, file = "clean_data/statistics/beta_perm4_terms.rds")
beta_perm4_terms <- readRDS("clean_data/statistics/beta_perm4_terms.rds")

# By Habitat*Genotype
set.seed(123)
beta_dis5 <- betadisper(
    vegdist(dbrda_hell_matrix, method = "bray"),
    dbrda_traits$Habitat_Genotype,
    type = "median",
    sqrt.dist = FALSE
)
saveRDS(beta_dis5, file = "clean_data/statistics/beta_dis5.rds")
beta_dis5 <- readRDS("clean_data/statistics/beta_dis5.rds")

TukeyHSD(beta_dis5)
## Permutest
## Margin
set.seed(123)
beta_perm5_margin <-
    permutest(beta_dis5,
              parallel = 10,
              permutations = 999,
              by = "margin")
saveRDS(beta_perm5_margin, file = "clean_data/statistics/beta_perm5_margin.rds")
beta_perm5_margin <- readRDS("clean_data/statistics/beta_perm5_margin.rds")
TukeyHSD(beta_perm5_margin)

## Terms
set.seed(123)
beta_perm5_terms <-
    permutest(beta_dis5,
              parallel = 10,
              permutations = 999,
              by = "terms")
saveRDS(beta_perm5_terms, file = "clean_data/statistics/beta_perm5_terms.rds")
```
The groups interacting with the environment (Habitat_Genotype) show significant differences in multivariate dispersion (p \< 0.05). The PERMDISP analysis shows that the groups are significantly different in their multivariate dispersion.Group differences are due to dispersion differences between groups, not due to differences in the median of the groups.

#### hybrids only
```{r}
#################################################################
#### dbRDA modelling for all samples: hybrids ONLY ####
#################################################################

##### Hellinger transformed rarefied data
dbrda_hybrids_matrix <- rrfy_hell_matrix |>
  column_to_rownames(var = "X") |>
  select(-c(1, 2:17)) |>
  t() |>
  as.data.frame() |>
  select(contains(c("F2WY", "F2YW"))) |>
  t() |>
  as.data.frame()

saveRDS(dbrda_hybrids_matrix, file = "clean_data/statistics/dbrda_hybrids_matrix.rds")
dbrda_hybrids_matrix <- readRDS(file.path(path,"clean_data/statistics/dbrda_hybrids_matrix.rds"))


dbrda_hybrids_traits <- rrfy_hell_matrix |>
  select(X, Unique_ID, Site, Habitat, Genotype, logLBI) |>
  filter(X %in% rownames(dbrda_hybrids_matrix)) |>
   unite(Habitat_Genotype,
        Habitat,
        Genotype,
        sep = "_",
        remove = FALSE) # To model interactions
saveRDS(dbrda_hybrids_traits, file = "clean_data/statistics/dbrda_hybrids_traits.rds")
#dbrda_hybrids_traits <- readRDS(file.path(path, "clean_data/statistics/dbrda_hybrids_traits.rds"))


# Model with intercept only ####
# Using rrfy_hell_matrix as the distance matrix
m0_hybrids_hell <- dbrda(
    dbrda_hybrids_matrix ~ 1,
    distance = "bray",
    dfun = vegdist,
    data = dbrda_hybrids_traits,
    parallel = 20, #Passes parallelization to metaMDS function
    na.action = na.omit
) #Model with intercept only.
saveRDS(m0_hybrids_hell, file = "clean_data/statistics/m0_hybrids_hell.rds")

m1_hybrids_hell <- dbrda(
    dbrda_hybrids_matrix ~ .,
    distance = "bray",
    dfun = vegdist,
    data = dbrda_hybrids_traits,
    parallel = 20,
    na.action = na.omit
) # Model with all explanatory variables.
saveRDS(m1_hybrids_hell, file = "clean_data/statistics/m1_hybrids_hell.rds")

# Model with species, site, leaf traits and elevation. ####
m2_hybrids_hell <-
    dbrda(
        dbrda_hybrids_matrix ~ logLBI + Habitat + Genotype,
        distance = "bray",
        dfun = vegdist,
        data = dbrda_hybrids_traits,
        parallel = 20,
        na.action = na.omit
    )
saveRDS(m2_hybrids_hell, file = "clean_data/statistics/m2_hybrids_hell.rds")

#Anovas for m2
## Margin
set.seed(123)
anova_m2_hybrids_margin <- anova.cca(
    m2_hybrids_hell,
    by = "margin",
    permutations = 999,
    parallel = 20
)
saveRDS(anova_m2_hybrids_margin, file = "clean_data/statistics/anova_m2_hybrids_margin.rds")

## Terms
set.seed(123)
anova_m2_hybrids_terms <- anova.cca(
    m2_hybrids_hell,
    by = "terms",
    permutations = 999,
    parallel = 20
)
saveRDS(anova_m2_hybrids_terms, file = "clean_data/statistics/anova_m2_hybrids_terms.rds")


# m3 hybrids
m3_hybrids_hell <-
  dbrda(
    dbrda_hybrids_matrix ~ logLBI + Habitat * Genotype,
    distance = "bray",
    dfun = vegdist,
    data = dbrda_traits,
    parallel = 20,
    na.action = na.omit
  )
saveRDS(m3_hybrids_hell, file = "clean_data/statistics/m3_hybrids_hell.rds")

#Anovas for m3_hybrids
#Margins
set.seed(123)
anova_m3_hybrids_margin <- anova.cca(m3_hell,
                                  by = "margin",
                                  permutations = 999,
                                  parallel = 10)
saveRDS(anova_m3_hybrids_margin, file = "clean_data/statistics/anova_m3_hybrids_margin.rds")

#Terms
set.seed(123)
anova_m3_hybrids_term <- anova.cca(m3_hell,
                                by = "terms",
                                permutations = 999,
                                parallel = 10)
saveRDS(anova_m3_hybrids_term, file = "clean_data/statistics/anova_m3_hybrids_term.rds")



### PERMDISP

#Analysis of multivariate homogeneity of group dispersions.

# By Genotype
set.seed(123)
beta_hybrids_dis1 <-
    betadisper(
        vegdist(dbrda_hybrids_matrix, method = "bray"), # Matrix of Hellinger transformed data rarefied
        dbrda_hybrids_traits$Genotype,
        type = "median",
        sqrt.dist = FALSE
    )
saveRDS(beta_hybrids_dis1, file = "clean_data/statistics/beta_hybrids_dis1.rds")
beta_hybrids_dis1 <- readRDS("clean_data/statistics/beta_hybrids_dis1.rds")

anova(beta_hybrids_dis1)
TukeyHSD(beta_hybrids_dis1)


## Permutest
## Margin
set.seed(123)
beta_hybrids_perm1_margin <-
    permutest(beta_hybrids_dis1,
              parallel = 10,
              permutations = 999,
              by = "margin")
saveRDS(beta_hybrids_perm1_margin, file = "clean_data/statistics/beta_hybrids_perm1_margin.rds")
beta_hybrids_perm1_margin <- readRDS("clean_data/statistics/beta_hybrids_perm1_margin.rds")

beta_hybrids_perm1_margin

## Terms
set.seed(123)
beta_hybrids_perm1_terms <-
    permutest(beta_hybrids_dis1,
              parallel = 10,
              permutations = 999,
              by = "terms")
saveRDS(beta_hybrids_perm1_terms, file = "clean_data/statistics/beta_hybrids_perm1_terms.rds")

# By Habitat
set.seed(123)
beta_hybrids_dis2 <- betadisper(
    vegdist(dbrda_hybrids_matrix, method = "bray"),
    dbrda_traits$Habitat,
    type = "median",
    sqrt.dist = FALSE
)
saveRDS(beta_hybrids_dis2, file = "clean_data/statistics/beta_hybrids_dis2.rds")

## Permutest
## Margin
set.seed(123)
beta_hybrids_perm2_margin <-
    permutest(beta_dis2,
              parallel = 10,
              permutations = 999,
              by = "margin")
saveRDS(beta_hybrids_perm2_margin, file = "clean_data/statistics/beta_hybrids_perm2_margin.rds")

## Terms
set.seed(123)
beta_hybrids_perm2_terms <-
    permutest(beta_dis2,
              parallel = 10,
              permutations = 999,
              by = "terms")
saveRDS(beta_hybrids_perm2_terms, file = "clean_data/statistics/beta_hybrids_perm2_terms.rds")

# By Habitat*Genotype
set.seed(123)
beta_hybrids_dis3 <- betadisper(
    vegdist(dbrda_hybrids_matrix, method = "bray"),
    dbrda_traits$Habitat_Genotype,
    type = "median",
    sqrt.dist = FALSE
)
saveRDS(beta_hybrids_dis3, file = "clean_data/statistics/beta_hybrids_dis3.rds")

## Permutest
## Margin
set.seed(123)
beta_hybrids_perm3_margin <-
    permutest(beta_dis3,
              parallel = 10,
              permutations = 999,
              by = "margin")
saveRDS(beta_hybrids_perm3_margin, file = "clean_data/statistics/beta_hybrids_perm3_margin.rds")

## Terms
set.seed(123)
beta_hybrids_perm3_terms <-
    permutest(beta_dis3,
              parallel = 10,
              permutations = 999,
              by = "terms")
saveRDS(beta_hybrids_perm3_terms, file = "clean_data/statistics/beta_hybrids_perm3_terms.rds")
```



#### Plot dbRDA

##### Full model

```{r, full_model}
# Final model
load("clean_data/statistics/m2_hell.rda")
final_model <- m2_hell

names(final_model)
finalm_summary <- summary(final_model)


# Extracting scores for the plot
ordination_scores <- as.data.frame(vegan::scores(final_model)$sites)

# Extracting names for the plot
ordination_names <- rownames(ordination_scores)

# Row names to column
ordination_scores$Unique_ID <- rownames(ordination_scores)

# Subset for the plot
dbrda_df <- plant_traits_rfy

# Merge scores with trait data
merged_data <- right_join(ordination_scores, dbrda_df, by = c("Unique_ID" = "X"))

# Extracting scores for arrows
arrow_scores <- as.data.frame(vegan::scores(final_model, display = "bp"))

# Define the arrow aesthetic mapping
arrow_map <- aes(
  xend = (dbRDA1 * 2),
  yend = (dbRDA2 * 2),
  x = 0,
  y = 0,
  shape = NULL,
  color = NULL,
  fill = NULL
)
label_map <- aes(
  x = 2 * dbRDA1,
  y = 2 * dbRDA2,
  label = row.names(arrow_scores),
  shape = NULL,
  color = NULL,
  fill = NULL
)
arrowhead = arrow(length = unit(0.02, "npc"))

#subset A4 for labeling
arrow_scores <- arrow_scores[order(rownames(arrow_scores)), ]
A4 <- lapply(1:6, function(i)
  arrow_scores[i, ])

# A4.sub1 <- arrow_scores[1,] #Elevation
# A4.sub2 <- arrow_scores[2,] #ACi
# A4.sub3 <- arrow_scores[3,] #LBI
A4.sub4 <- arrow_scores[4, ] #logLBI
# A4.sub5 <- arrow_scores[5,] #LPS
# A4.sub6 <- arrow_scores[6,] #LT.

# dbRDA plot based on species
full_final_model <- ggplot(data = merged_data, aes(x = dbRDA1, y = dbRDA2)) +
  geom_point(
    data = merged_data,
    aes(color = Genotype, shape = Site),
    size = rel(4),
    alpha = 0.2,
    stroke = 1
  ) +
  geom_segment(
    arrow_map,
    size = rel(.8),
    data = arrow_scores,
    color = "black",
    arrow = arrowhead
  ) +
  geom_vline(xintercept = 0,
             color = "grey30",
             linetype = "dashed") + # plot vertical line
  geom_hline(yintercept = 0,
             color = "grey30",
             linetype = "dashed") + # plot horizontal line
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[1]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("F2WY"),
    hjust = 1.2
  ) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[2]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("G"),
    vjust = 1.3
  ) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[3]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("L"),
    vjust = -0.6
  ) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[4]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("logLBI"),
    hjust = -0.1
  ) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[5]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("LM"),
    hjust = -0.2
  ) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[6]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("OPN"),
    vjust = -0.3,
    hjust = 1.2
  ) +
  xlab(label = paste(
    "dbRDA1 (",
    round(finalm_summary$concont$importance[2, 1] * 100, digits = 1),
    "%)",
    sep = ""
  )) +
  ylab(label = paste(
    "dbRDA2 (",
    round(finalm_summary$concont$importance[2, 2] * 100, digits = 1),
    "%)",
    sep = ""
  )) +
  scale_color_manual(values = met.brewer(
    "Johnson",
    n = 4,
    type = "discrete",
    direction = 1
  )) +
  scale_shape_manual(values = c(1:22)) +
  stat_ellipse(
    aes(color = Genotype),
    geom = "path",
    linewidth = 1.7,
    position = "identity",
    type = "t",
    linetype = 1,
    level = 0.95,
    segments = 51,
    na.rm = FALSE,
    show.legend = NA,
    inherit.aes = TRUE
  ) +
  theme_classic(base_size = 16) +
  theme(legend.title = element_text(face = "bold")) +
  guides(shape = guide_legend(ncol = 2))


# Rearranging the order of layers so arrows are above the points.
full_final_model$layers
full_final_model$layers <- c(
  full_final_model$layers,
  full_final_model$layers[[2]],
  full_final_model$layers[[5]],
  full_final_model$layers[[6]],
  full_final_model$layers[[7]],
  full_final_model$layers[[8]],
  full_final_model$layers[[9]],
  full_final_model$layers[[10]]
)
full_final_model

ggsave(
  filename = file.path(path, "figures/dbRDA_full_model.png"),
  plot = full_final_model,
  dpi = 600,
  units = c("mm"),
  width = 150,
  height = 150
)

######################################
#### Full model with interactions ####
######################################
load("clean_data/statistics/m3_hell.rda")
final_inter_model <- m3_hell

names(final_inter_model)
final_inter_summary <- summary(final_inter_model)


# Extracting scores for the plot
ordination_scores <- as.data.frame(vegan::scores(final_inter_model)$sites)

# Extracting names for the plot
ordination_names <- rownames(ordination_scores)

# Row names to column
ordination_scores$Unique_ID <- rownames(ordination_scores)

# Subset for the plot
dbrda_df <- plant_traits_rfy 

# Merge scores with trait data
merged_data <- right_join(ordination_scores, dbrda_df, by = c("Unique_ID" = "X"))

# Extracting scores for arrows
arrow_scores <- as.data.frame(vegan::scores(final_inter_model, display = "bp"))

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = (dbRDA1*2), yend = (dbRDA2*2), x = 0, y = 0, shape = NULL, color = NULL, fill = NULL)
label_map <- aes(x = 2*dbRDA1, y = 2*dbRDA2, label = row.names(arrow_scores), shape = NULL, color = NULL, fill = NULL)
arrowhead = arrow(length = unit(0.02, "npc"))
#subset A4 for labeling
arrow_scores <- arrow_scores[order(rownames(arrow_scores)), ]
A4 <- lapply(1:12, function(i) arrow_scores[i, ])

# A4.sub1 <- arrow_scores[1,] #Elevation
# A4.sub2 <- arrow_scores[2,] #ACi
# A4.sub3 <- arrow_scores[3,] #LBI
A4.sub4 <- arrow_scores[4,] #logLBI
# A4.sub5 <- arrow_scores[5,] #LPS
# A4.sub6 <- arrow_scores[6,] #LT.

# dbRDA plot based on species
full_final_inter_model <-
  ggplot(data = merged_data, aes(x = dbRDA1, y = dbRDA2)) +
  geom_point(
    data = merged_data,
    aes(color = Genotype, shape = Habitat),
    size = rel(4),
    alpha = 0.05,
    stroke = 1
  ) +
  stat_ellipse(
    aes(color = Genotype),
    geom = "path",
    linewidth = 1.7,
    position = "identity",
    type = "t",
    linetype = 1,
    level = 0.95,
    segments = 51,
    na.rm = FALSE,
    show.legend = NA,
    inherit.aes = TRUE
  ) +
  geom_segment(
    arrow_map,
    size = rel(.8),
    data = arrow_scores,
    color = "black",
    arrow = arrowhead
  )+
  geom_vline(xintercept = 0,
             color = "grey30",
             linetype = "dashed") + # plot vertical line
  geom_hline(yintercept = 0,
             color = "grey30",
             linetype = "dashed") + # plot horizontal line
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[1]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("F2xLG")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[2]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("G")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[3]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("L")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[4]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("Granite 1")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[5]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("G1:F2xLG")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[6]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("G1:G")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[7]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("G1:L")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[8]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("Meadow 2")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[9]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("M2:F2xLG")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[10]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("M2:G")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[11]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("M2:L")
  ) +
  geom_text_repel(
    label_map,
    size = rel(4),
    data = A4[[12]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("logLBI")
  ) +
  xlab(label = paste(
    "dbRDA1 (",
    round(final_inter_summary$concont$importance[2, 1] * 100, digits = 1),
    "%)",
    sep = ""
  )) +
  ylab(label = paste(
    "dbRDA2 (",
    round(final_inter_summary$concont$importance[2, 2] * 100, digits = 1),
    "%)",
    sep = ""
  )) +
  scale_color_manual(
    labels = c("F2xGL", "G", "L", "F2xLG"),
    values = met.brewer(
      "Johnson",
      n = 4,
      type = "discrete",
      direction = 1
    )
  ) +
  scale_shape_manual(values = c(0:3)) +
  #scale_x_continuous(limits = c(-2, 2)) + # Needed to scale points the sames as when ellipses are present.
  theme_classic(base_size = 16) +
  theme(
    legend.title = element_text(face = "bold"),
    legend.text = element_markdown(),
    plot.caption = element_markdown(),
    strip.text = element_text(face = "bold")
  ) +
  labs(caption = "PERMDISP: *F*<sub>11, 14088</sub> = 471.62, *p* = .001") +
  facet_wrap( ~ Habitat) +
  guides(shape = guide_legend(ncol = 1))

     
# Rearranging the order of layers so arrows are above the points.
# full_final_inter_model$layers <- c(full_final_inter_model$layers,full_final_inter_model$layers[[2]], full_final_inter_model$layers[[5]], full_final_inter_model$layers[[6]], full_final_inter_model$layers[[7]], full_final_inter_model$layers[[8]], full_final_inter_model$layers[[9]], full_final_inter_model$layers[[10]], full_final_inter_model$layers[[11]])
full_final_inter_model

# Saving by layers for PowerPoint presentation

# Just points
# ggsave(filename=file.path(path, "figures/dbRDA_full_model_points.png"), plot = full_final_model, dpi=300, units=c("mm"), width=250, height=150)
# 
# # Adding ellipses
# ggsave(filename=file.path(path, "figures/dbRDA_full_model_ellipses.png"), plot = full_final_model, dpi=300, units=c("mm"), width=250, height=150)
# 
# # Adding arros and labels (points at aplha = 0.05)
 ggsave(filename=file.path(path, "figures/dbRDA_full_model_labels.svg"), plot = full_final_model, dpi=300, units=c("mm"), width=250, height=150)

```

##### Hybrid model

```{r, hybrid_model}
load("clean_data/statistics/m2_hybrids_hell.rda")
hybrid_model <- m2_hybrids_hell

names(hybrid_model)
B <- summary(hybrid_model)
vegan::scores(hybrid_model)

# Extracting scores for the plot
ordination_scores <- as.data.frame(vegan::scores(hybrid_model)$sites)

# Extracting names for the plot
ordination_names <- rownames(ordination_scores)

# Row names to column
ordination_scores$Unique_ID <- rownames(ordination_scores)

# Subset for the plot
dbrda_df <- plant_traits_rfy |>
  filter(X %in% ordination_names, Genotype == "F2WY" |
           Genotype == "F2YW") # Extra filtering to remove parentals

# Merge scores with trait data
merged_data <- right_join(ordination_scores, dbrda_df, by = c("Unique_ID" = "X"))

# Extracting scores for arrows
arrow_scores <- as.data.frame(vegan::scores(hybrid_model, display = "bp"))

# Define the arrow aesthetic mapping
arrow_map <- aes(
  xend = (dbRDA1 * 2),
  yend = (dbRDA2 * 2),
  x = 0,
  y = 0,
  shape = NULL,
  color = NULL,
  fill = NULL
)
label_map <- aes(
  x = 2 * dbRDA1,
  y = 2 * dbRDA2,
  label = row.names(arrow_scores),
  shape = NULL,
  color = NULL,
  fill = NULL
)
arrowhead = arrow(length = unit(0.02, "npc"))

#subset A4 for labeling
arrow_scores <- arrow_scores[order(rownames(arrow_scores)), ]
A4 <- lapply(1:6, function(i)
  arrow_scores[i, ])

# A4.sub1 <- arrow_scores[1,] #Elevation
# A4.sub2 <- arrow_scores[2,] #ACi
# A4.sub3 <- arrow_scores[3,] #LBI
A4.sub4 <- arrow_scores[4, ] #logLBI
# A4.sub5 <- arrow_scores[5,] #LPS
# A4.sub6 <- arrow_scores[6,] #LT.

# dbRDA plot based on species
hybrid_model <- ggplot(data = merged_data, aes(x = dbRDA1, y = dbRDA2)) +
  geom_point(
    data = merged_data,
    aes(color = Genotype, shape = Site),
    size = rel(4),
    alpha = 0.2,
    stroke = 1
  ) +
  geom_segment(
    arrow_map,
    size = rel(.8),
    data = arrow_scores,
    color = "black",
    arrow = arrowhead
  ) +
  geom_vline(xintercept = 0,
             color = "grey30",
             linetype = "dashed") + # plot vertical line
  geom_hline(yintercept = 0,
             color = "grey30",
             linetype = "dashed") + # plot horizontal line
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[1]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("F2WY"),
    hjust = 1.2
  ) +
  # geom_text(label_map, size = rel(4), data = A4[[2]], fontface = "bold", show.legend = FALSE, label = c("G"),  vjust = 1.3 ) +
  # geom_text(label_map, size = rel(4), data = A4[[3]], fontface = "bold", show.legend = FALSE, label = c("L"), vjust = -0.6) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[4]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("logLBI"),
    hjust = -0.1
  ) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[5]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("LM"),
    hjust = -0.2
  ) +
  geom_text(
    label_map,
    size = rel(4),
    data = A4[[6]],
    fontface = "bold",
    show.legend = FALSE,
    label = c("OPN"),
    vjust = -0.3,
    hjust = 1.2
  ) +
  xlab(label = paste(
    "dbRDA1 (",
    round(B$concont$importance[2, 1] * 100, digits = 1),
    "%)",
    sep = ""
  )) +
  ylab(label = paste(
    "dbRDA2 (",
    round(B$concont$importance[2, 2] * 100, digits = 1),
    "%)",
    sep = ""
  )) +
  scale_color_manual(values = met.brewer(
    "Johnson",
    n = 4,
    type = "discrete",
    direction = 1
  )) +
  scale_shape_manual(values = c(1:22)) +
  stat_ellipse(
    aes(color = Genotype),
    geom = "path",
    linewidth = 1.7,
    position = "identity",
    type = "t",
    linetype = 1,
    level = 0.95,
    segments = 51,
    na.rm = FALSE,
    show.legend = NA,
    inherit.aes = TRUE
  ) +
  theme_classic(base_size = 16) +
  theme(legend.title = element_text(face = "bold")) +
  guides(shape = guide_legend(ncol = 2))


# Rearranging the order of layers so arrows are above the points.
hybrid_model$layers
hybrid_model$layers <- c(
  hybrid_model$layers,
  hybrid_model$layers[[2]],
  hybrid_model$layers[[5]],
  hybrid_model$layers[[6]],
  hybrid_model$layers[[7]],
  hybrid_model$layers[[8]],
  hybrid_model$layers[[9]],
  hybrid_model$layers[[10]]
)
hybrid_model

#ggsave(filename=file.path(path, "figures/dbRDA_hybrid model.png"), plot = hybrid_model, dpi=600, units=c("mm"), width=150, height=150)
```

### PERMANOVA

```{r, adonis2}
# Real data
set.seed(123)
perma <- adonis2(
  dbrda_hell_matrix ~ logLBI + Site + Genotype,
  data = dbrda_traits,
  method = "bray",
  parallel = 8,
  permutation = 999,
  na.action = na.omit,
  strata = NULL
)
print(perma)#

# Rarefied data
set.seed(123)
perma2 <-
  adonis2(
    dbrda_hell_matrix ~ logACI + logLT + logLPS + logLMA +
      Elevation_m +
      Species,
    data = dbrda_traits,
    method = "bray",
    parallel = 8,
    permutation = 999,
    na.action = na.omit,
    strata = NULL
  )
print(perma2)

# Simulated data
set.seed(123)
perma3 <- adonis2(dbrda_hell_matrix ~ logACI + logLT + logLPS + logLMA +
                   Elevation_m + 
                   Species,
                 data = sim_traits,
                 method = "bray",
                 parallel = 8,
                 permutation = 999, 
                 na.action = na.omit, 
                 strata = NULL)
print(perma3)
```

### SIMPER
Who contributes more to differences in the community composition?

```{r, SIMPER}
(sim <- with(dbrda_traits, simper(dbrda_hell_matrix, Species, permutations = 9999, parallel = 8)))
summary(sim)
```

## GLMMs

### Beta Diversity

using `dbrda_traits` dataset for GLMMs. It's a subset of the `rrfy_hell_matrix` (`plant_traits_rfy` + community matrix) dataset.
```{r}
# Bray-Curtis dissimilarity vs. Elevation

# Mean-Bray-Curtis dissimilarity
mean_bray <- vegdist(dbrda_hell_matrix, method = "bray") |>
  as.matrix() |>
  as.data.frame()
saveRDS(mean_bray, file = "clean_data/statistics/mean_bray.rds")
mean_bray <- readRDS("clean_data/statistics/mean_bray.rds")

mean_bray <- rownames_to_column(mean_bray, var = "Unique_ID") |>
  mutate(mean_bray = rowMeans(mean_bray)) |>
  select(Unique_ID, mean_bray)

# Joining to dbrda_traits to avoid duplicate DFs 
dbrda_traits <- left_join(dbrda_traits, mean_bray, by = c("X"= "Unique_ID"))
```


#### Selecting fixed terms
```{r, glm}
# GLMs with Beta Diversity
b1 <- glm(
  mean_bray ~ Habitat * Genotype + logLBI,
  data = dbrda_traits,
  family = gaussian
) # Gaussian/Normal distribution
plot(b1)
anova(b1)
AIC(b1)

# Model with intercept only
B0 <- lm(mean_bray ~ 1, data = dbrda_traits, na.action = na.exclude)
anova(B0)
AIC(B0)
plot(B0)


################################################
# B1 Model with Habitat and Genotype
################################################
# All data points
B1 <- lm(
  mean_bray ~ Habitat * Genotype + logLBI,
  data = dbrda_traits,
  na.action = na.exclude
)
anova(B1)
AIC(B1) # -32950.55


# Model validation
# Residuals
B1_resid <- resid(B1, type = "response")
B1_fitted <- fitted(B1)

#Histograms
hist(B1_resid)
hist(B1_fitted)

# predicted vs. actual values
plot(
  x = predict(B1),
  y = dbrda_traits$mean_bray,
  xlab = 'Predicted Values',
  ylab = 'Actual Values',
  main = 'B1 Predicted vs. Actual Values'
)
abline(a = 0, b = 1)

anova(B1, type="marginal")
Anova(B1, type = 3)
#drop1(B1, . ~ ., test = "F", trace = TRUE)

# Stepwise selection of linear model (lm())
B1AIC <- stepAIC(update(B1, . ~ .), direction = "both", k = 2)
B1AIC$anova

#Final Model:
#mean_bray ~ Species + Site + logACI + logLT + logLPS + logLMA + logLBI


################################################
# B2 Model
################################################
B2 <- lm(
  mean_bray ~ Habitat + Genotype + logLBI,
  data = dbrda_traits,
  na.action = na.exclude
)

anova(B2)
Anova(B2, type = 3)
AIC(B2) #-13617.24

# Residuals
B2_resid <- resid(B2, type = "response")
B2_fitted <- fitted(B2)

#Histograms
hist(B2_resid)
hist(B2_fitted)

# predicted vs. actual values
plot(
  x = predict(B2),
  y = dbrda_traits$mean_bray,
  xlab = 'Predicted Values',
  ylab = 'Actual Values',
  main = 'B2 Predicted vs. Actual Values'
)
abline(a = 0, b = 1)

# Stepwise selection of linear model 
B2AIC <- stepAIC(update(B2, . ~ .), trace = TRUE, direction = "both", k = 2)
B2AIC$anova

# No fixed term removed.
```

B1 and B2 models have about the same AIC score (-66k). B1 includes the interaction of `Habitat` and `Genotype`, while B2 does not.


#### Modelling random effects with "ML" method

Starting with fixed terms selected above.

```{r, random_effects}
################################################
# B3 Model with Species as fixed term and site as random effect
################################################
#B3
B3 <- lme(
  mean_bray ~ Habitat * Genotype + logLBI,
  random = ~ 1 | Site,
  method = "ML",
  data = na.omit(dbrda_traits)) 

Anova(B3, type = 3)
AIC(B3) #  -32948.55

# Residuals histograms and plots ####
B3_resid <- resid(B3, type = "response")
B3_fitted <- fitted(B3)

# Histograms
hist(B3_resid)
hist(B3_fitted)

# Plots
plot(
  x = predict(B3),
  y = dbrda_traits$mean_bray,
  xlab = 'Predicted Values',
  ylab = 'Actual Values',
  main = 'B3 Predicted vs. Actual Values'
)
abline(a = 0, b = 1)

plot_model(B3, type = "diag")

# Stepwise selection of terms
B3AIC <- stepAIC(update(B3, . ~ ., -1), direction = "both", k = 2)
B3AIC$anova
B3drop <- drop1(B3, . ~ ., test = "Chisq", trace = TRUE)

# No stepwise term deletion or dropping of terms.
```
 Modelling using maximum likelihood estimation increases AIC by 2 pts.

```{r, random_effects2}
# B5 
B4 <- lme(
  mean_bray ~ Genotype + logLBI,
  random = ~ 1 |
    Habitat,
  method = "ML",
  data = na.omit(dbrda_traits)
)
Anova(B4, type = 3)
AIC(B4) # -32499.53 is a higher AIC score than B3.

# Residuals histograms and plots ####
B4_resid <- resid(B4, type = "response")
B4_fitted <- fitted(B4)

# Histograms
hist(B4_resid)
hist(B4_fitted)

# Plots
plot(
  x = predict(B4),
  y = dbrda_traits$mean_bray,
  xlab = 'Predicted Values',
  ylab = 'Actual Values',
  main = 'B4 Predicted vs. Actual Values'
)
abline(a = 0, b = 1)

plot_model(B4, type = "diag")

# Stepwise selection of terms
B4AIC <- stepAIC(update(B4, . ~ ., -1),
                 trace = TRUE,
                 direction = "both",
                 k = 2)
B4AIC$anova
drop1(B4, . ~ ., test = "Chisq", trace = TRUE)

# NOthing eliminated.
```


#### REML modelling

Using Restricted Maximum Likelihood (REML) to model. Maximum likelihood tends to be biased with high dimensional data. No interactions yet, checking random effects. Cannot use `stepAIC` with `REML` models.

```{r, reml_models}
# REML
# B1REM All fixed terms
B1REM <- lme(
  mean_bray ~ Genotype + logLBI,
  random = ~ 1 |
    Habitat,
  method = "REML",
  data = na.omit(dbrda_traits))

Anova(B1REM, type = 3)
AIC(B1REM) #-32453.26 This is a higher score than ML models


B1_gls <- gls(
  mean_bray ~ Habitat * Genotype + logLBI,
  method = "REML",
  data = na.omit(dbrda_traits)
)

anova(B1_gls, type = "marginal")
#Anova(B1_gls, type = 3)
AIC(B1_gls) # -32820.01 is a lower AIC score. Site as a random effect is NOT important.

plot_model(B1REM, type = "diag")

# Model comparison
model.sel(B1, B2, B3, B4,B1REM, B1_gls)[, c("df", "logLik", "AICc", "delta")]

# Model B1 and B3 are the best models. B1 has a lower AIC score.
```

A brief online search explain these differences. REML is better at estimating random effect variance components, while ML is better at estimating fixed effects. Because we have a nested structure in this experiment we will continue with REML. 
*"When there is no model comparison, the difference between restricted (or residual) maximum likelihood (REML) and maximum likelihood (ML) is that, REML can give you unbiased estimates of the variance parameters."*
https://stats.stackexchange.com/questions/91652/when-no-model-comparison-should-i-use-reml-vs-ml


```{r, reml_models2}
# Modelling variance structure.
#Optimizers
ctrl <- lmeControl(opt='optim')
ctrl2 <- lmeControl(opt = "nlminb")

#B3REM
B3REM <- lme(
  mean_bray ~ Genotype + logLBI,
  weights = varIdent(form = ~ 1 | Habitat),
  random = ~ 1 |
    Habitat,
  method = "REML",
  control = ctrl,
  data = na.omit(dbrda_traits)
)

Anova(B3REM, type = 3)
AIC(B3REM) # -16249.18 is  a lower AIC score than B1REM

# Residuals histograms and plots ####
B3REM_resid <- resid(B3REM, type = "response")
B3REM_fitted <- fitted(B3REM)

# Histograms
hist(B3REM_resid)
hist(B3REM_fitted)

# Plots
plot(B3REM)
plot(
  x = predict(B3REM),
  y = dbrda_traits$mean_bray,
  xlab = 'Predicted Values',
  ylab = 'Actual Values',
  main = 'Predicted vs. Actual Values'
)
abline(a = 0, b = 1)
plot_model(B3REM, type = "diag")
```


```{r, reml_models3}
# Modelling variance structure better
# B4REM
B4REM <- lme(
  mean_bray ~ Genotype * logLBI,
  weights = varIdent(form = ~ 1 | Habitat),
  random = ~ 1 |
    Habitat,
  method = "REML",
  control = ctrl,
  data = na.omit(dbrda_traits)
)

anova(B4REM)
Anova(B4REM, type = 3)
AIC(B4REM) # -34253.34 this is greater than B3REM

# Residuals histograms and plots ####
B4REM_resid <- resid(B4REM, type = "response")
B4REM_fitted <- fitted(B4REM)

# Histograms
hist(B4REM_resid)
hist(B4REM_fitted)

# Plots
plot(B4REM)
plot_model(B4REM, type = "diag")

# B5REM
# B5REM <- lme(
#   mean_bray ~ logACI + logLT + logLMA + logLBI,
#   weights = varComb(varIdent(form = ~ 1 | Site), varIdent(form = ~ 1 | Species)),
#   random = ~ 1 |
#     Site/Species,
#   method = "REML",
#   control = ctrl,
#   data = na.omit(dbrda_traits_imp)
# )
# 
# Anova(B5REM, type = 3)
# AIC(B5REM) # -16603.6 the lowest AIC score
# 
# # Residuals histograms and plots ####
# B5REM_resid <- resid(B5REM, type = "response")
# B5REM_fitted <- fitted(B5REM)
# 
# # Histograms
# hist(B5REM_resid)
# hist(B5REM_fitted)
# 
# # Plots
# plot(B5REM)
# plot_model(B5REM, type = "diag")
```

One of the big issues is outliers. I need to identify outliers and decide if it's worth cutting from data set. 

#### Outliers
The `lobLBI` has many outliers in the ~0 range compared to the rest of the data. It looks almost binomial, either close to -1 or 0. I will remove these outliers and re-run the models with the remaining data.

```{r}
hist(dbrda_traits$logLBI) # 0.5 seems like a good cut off. 
no_outliers_dbrda_traits <- dbrda_traits %>%
  filter(logLBI < -0.5) # Removing outliers.
```

#### Modelling without outliers
```{r}

# Model with intercept only
N00 <- lm(mean_bray ~ 1, data = no_outliers_dbrda_traits, na.action = na.exclude)
anova(N00)
AIC(N00) #-24280.93 Greater AIC
plot(B0)

# Model N0
N0 <- lm(
  mean_bray ~ Habitat + Genotype + logLBI,
         data = no_outliers_dbrda_traits)
anova(N0)
AIC(N0) # -25094.5 Lower AIC

plot(N0)
plot_model(N0, type = "diag")

#Model N1
# GLMs with Beta Diversity
N1 <- glm(
  mean_bray ~ Habitat * Genotype * logLBI,
  data = no_outliers_dbrda_traits,
  family = gaussian(link = "identity")
) # Gaussian/Normal distribution
plot(N1)
anova(N1)
AIC(N1) # -26086.71 Lower AIC


# N2 (same as N0)
N2 <- lm(
  mean_bray ~ Habitat + Genotype + logLBI,
  data = no_outliers_dbrda_traits,
  na.action = na.exclude
)

anova(N2)
Anova(N2, type = 3)
AIC(N2) #-25094.5

# Residuals
N2_resid <- resid(N2, type = "response")
N2_fitted <- fitted(N2)

#Histograms
hist(N2_resid)
hist(N2_fitted)

# predicted vs. actual values
plot(
  x = predict(N2),
  y = no_outliers_dbrda_traits$mean_bray,
  xlab = 'Predicted Values',
  ylab = 'Actual Values',
  main = 'N2 Predicted vs. Actual Values'
)
abline(a = 0, b = 1)

plot_model(N2, type = "diag")

# Stepwise selection of linear model 
N2AIC <- stepAIC(update(N2, . ~ .), trace = TRUE, direction = "both", k = 2)
N2AIC$anova
```

No single term deletions in stepwise selection. 

```{r}
#N3
N3 <- lme(
  mean_bray ~ Genotype + logLBI,
  random = ~ 1 | Habitat,
  method = "ML",
  data = no_outliers_dbrda_traits)

Anova(N3, type = 3)
AIC(N3) #  -25073.77 is a HIGHER AIC score than N2

# Residuals histograms and plots ####
N3_resid <- resid(N3, type = "response")
N3_fitted <- fitted(N3)

# Histograms
hist(N3_resid)
hist(N3_fitted)

# Plots
plot(
  x = predict(N3),
  y = no_outliers_dbrda_traits$mean_bray,
  xlab = 'Predicted Values',
  ylab = 'Actual Values',
  main = 'N3 Predicted vs. Actual Values'
)
abline(a = 0, b = 1)

plot_model(N3, type = "diag")

# Stepwise selection of terms
N3AIC <- stepAIC(update(N3, . ~ ., -1), direction = "both", k = 2)
N3AIC$anova
N3drop <- drop1(N3, . ~ ., test = "Chisq", trace = TRUE)

# N4_gls
# N4_gls <- gls(
#   mean_bray ~ Habitat * Genotype + logLBI,
#   method = "REML",
#   data = na.omit(no_outliers_dbrda_traits)
# )

# N4_gls did not work. It reached singularity.
# Error in glsEstimate(glsSt, control = glsEstControl) : 
#   computed "gls" fit is singular, rank 11


N4 <- lme(
  mean_bray ~ Genotype + logLBI,
  weights = varIdent(form = ~ 1 | Habitat),
  random = ~ 1 |
    Habitat,
  method = "ML",
  data = no_outliers_dbrda_traits
)

Anova(N4, type = 3)
AIC(N4) # -25381.63 is a lower AIC score than N3


# N5
N5 <- lme(mean_bray ~ Genotype * logLBI,
          weights = varIdent(form = ~ 1 | Habitat),
          random = ~ 1 | Habitat,
          method = "REML",
          data = no_outliers_dbrda_traits
        )
anova(N5)
AIC(N5) # -25333.75 is Higher than N4

plot_model(N5, type = "diag")
```


<!-- #### Modelling by habitat -->
<!-- ```{r} -->
<!-- # By Habitat -->
<!-- B1_habitat <- dbrda_traits %>% -->
<!--   nest(data = -Habitat) %>% -->
<!--   mutate(model = map(data, ~ lm(mean_bray ~ Genotype * logLBI, data = ., na.action = na.exclude)), tidied = map(model, tidy)) %>% -->
<!--     unnest(tidied) -->
<!-- AIC(B1_habitat$model[[1]]) #-12406.4 -->

<!-- # by Genotype/crosstype -->
<!-- B1_genotype <- dbrda_traits %>% -->
<!--   nest(data = -Genotype) %>% -->
<!--   mutate(model = map(data, ~ lm(mean_bray ~ Habitat + logLBI, data = .)), tidied = map(model, tidy)) %>% -->
<!--   unnest(tidied) -->

<!-- AIC(B1_genotype$model[[1]]) #-14580.2 -->
<!-- # B1_habitat_df <- rowwise(B1_habitat) %>% do(tidy(.$model)) %>% -->
<!-- #   mutate(Habitat = B1_habitat$Habitat) %>% -->
<!-- #   as.data.frame() -->
<!-- #    -->
<!-- ``` -->
#### Model comparisons

```{r}
# Saving model objects
save(N1, N2, N3, N4, N4, file = "clean_data/statistics/glmm_models.rda")

load("clean_data/statistics/glmm_models.rda")

#Model comparison and selection
model.sel(N1, N2, N3, N4, N5)[, c("df", "logLik", "AICc", "delta")]
```


```{r, reml_models4}
# Model estimate plot
model_plots <- plot_models(
  N1,
  N2,
  N3,
  N4,
  N5,
  legend.title = "Models",
  show.values = TRUE,
  show.p = FALSE,
  p.shape = TRUE,
  dot.size = 5,
  std.est = NULL
)+
  
  #theme_classic(base_size = 16) +
  ylim(-0.15, 0.15) +
  geom_hline(yintercept = 0,
             color = "grey30",
             linetype = "dashed") # plot vertical line
model_plots

ggsave(file.path(path, "figures/model_plots.png"), plot = model_plots, dpi=300, units=c("mm"), width=300, height=300)
```

```{r}
# Model table comparisons
model_tables <- tab_model(
  N1,
  N2,
  N3,
  N4,
  N5,
  show.aic = TRUE,
  show.intercept = TRUE,
  show.df = FALSE,
  show.ci = 0.95,
  
  title = "Generalized Linear Mixed Effects models for predicting FEF mean Beta diversity",
  CSS = list(
    css.depvarhead = 'font-weight:bold;',
    css.centeralign = 'text-align: left;',
    css.firsttablecol = 'font-weight: bold;',
    css.summary = 'color: grey; font-weight: bold;',
    p.style = "numeric_stars")
    #file = file.path(path, "tables/model_tables.html")
)


model_tables


# Huxtable
table1 <- huxreg(
  "Model 1" = N1,
  "Model 2" = N2,
  "Model 3" = N3,
  "Model 4" = N4,
  # coefs = c(
  #   "Intercept" = "(Intercept)",
  #   "M. nasutus" = "SpeciesM. nasutus",
  #   "M. guttatus" = "SpeciesM. guttatus",
  #   "Elevation" = "Elevation_m",
  #   "ACI" = "logACI",
  #   "LT" = "logLT",
  #   "LPS" = "logLPS",
  #   "LMA" = "logLMA",
  #   "LBI" = "logLBI"
  # ), 
  error_pos = "right",
  error_format = "({conf.low} - {conf.high} ) [{statistic}]",
  number_format = "%.3f",
  align = ".",
  ci_level = 0.95,
  stars = c(`***` = 0.001, `**` = 0.01, `*` = 0.05),
  bold_signif = 0.05,
  borders = 0.4,
  outer_borders = 0.8,
  note = "Significance levels are represented by asterisks [p < 0.05 (*), p < 0.01 (**), p < 0.001 (***), and p < 0.0001 (****)]. T statistics in brackets.",
  statistics = c("N" = "nobs", "logLik", "AIC")
) |>
  insert_row("Predictors",
             "Estimate",
             "CI [t-statistic]",
             "Estimate",
             "CI [t-statistic]",
             "Estimate",
             "CI [t-statistic]",
             "Estimate",
             "CI [t-statistic]",
             after = 1) |>
  insert_row("Random effects", "", "", "", "", "", "", "", "", after = 11) |>
  set_all_padding(10) |>
  set_outer_padding(0) |>
  set_bold(row = 1, col = everywhere) |>
  #set_bottom_border(row = 1, col = everywhere) |>
  set_width(1.1) |>
  theme_article() |> #flextable::theme_apa() is good too.
  huxtable::as_flextable(column_to_header = TRUE) |>
  hline(12,
        part = "all",
        border = fp_border(
          color = "black",
          style = "solid",
          width = 1
        )) |> 
  hline(15,
        part = "all",
        border = fp_border(
          color = "black",
          style = "solid",
          width = 1.25
        )) |>
  hline(
    i = 1,
    j = c(2:9),
    part = "body",
    border = fp_border(
      color = "black",
      style = "solid",
      width = 1
    )
  ) |>
  flextable::align(
    i = 1:14,
    j = 2:9,
    align = "center",
    part = "body"
  ) |>
  flextable::style(i = c(1:16),
                   j = 1,
                   pr_t = fp_text(bold = FALSE)) |> 
  flextable::italic(
    i = c(4, 5, 12, 15),
    j = 1,
    italic = TRUE,
    part = "body"
  ) |>
  flextable::bold(
    i = c(2, 12),
    j = 1,
    bold = TRUE,
    part = "body"
  ) |>
  flextable::set_caption("Generalized linear mixed models (GLMMs) for predicting mean Bray-Curtis dissimilarity") |>
  flextable::font(
    i = NULL,
    j = NULL,
    fontname = "Tex Gyre Termes",
    part = "all",
    cs.family = fontname,
    hansi.family = fontname,
    eastasia.family = fontname
  )

knitr::knit_print(table1)

#save_as_docx(table1, path = "tables/model_comparison.docx")
#save_as_image(table1, path = "tables/model_comparison.svg")
```


# Indicator species analysis

This analysis allows us to determine what endophytes are associated with particular groups (e.g. tree species). According to this vignette from Cáceres ([2022](https://cran.r-project.org/web/packages/indicspecies/vignettes/IndicatorSpeciesAnalysis.html)) `multipatt` function can provides us with Indicators Value Index and correlation index. Both are similar, but the differences lies in the question they help answer. Indicator value index "\[...\]are used for assessing the predictive values of species as indicators of the conditions prevailing in site groups, e.g. for field determination of community types or ecological monitoring." While the correlation index can be used for "\[...\] determining the ecological preferences of species among a set of alternative site groups or site group combinations."

```{r, indicspp}

#Subset data frame for indicator species analysis
#Community Data
test <- as.matrix(t(rep_otu_df(pseq_rrfa)))
                 
asv_matrix_df <- as.data.frame(as.matrix(t(rep_otu_df(pseq_rrfa))))|># mirl object
  rownames_to_column(var = "Unique_ID") 
asv_indicspp <- left_join(asv_matrix_df, dbrda_traits, by = "Unique_ID")|> # Joining to the NMDS traits data frame which has the same number of rows as the asv_matrix_df
    select(!c(238:243)) |>
  relocate(Species, Site, Elevation_cat, Elevation_m, .after = Unique_ID)
```

```{r indicspp}
#Making vector of groups for analysis
set.seed(123)
indiabun <- asv_indicspp[, 7:ncol(asv_indicspp)]

species <- asv_indicspp$Species
elecat <- asv_indicspp$Elevation_cat
site <- asv_indicspp$Site

# Indicator species analysis`
multipatt_analysis = multipatt(indiabun, species, func = "r.g", control = how(nperm=999)) #By using abundance data and not presence-absence we are calculating the "point biserial correlation coefficient"
multipatt_analysis
summary(multipatt_analysis, indvalcomp = TRUE)


# Indicator species analysis by elevation category
multipatt_analysis_ele <- multipatt(indiabun, elecat, func = "r.g", control = how(nperm=999))
multipatt_analysis_ele
summary(multipatt_analysis_ele, indvalcomp = TRUE)

```

```{r, Type I errror and data table, tidy = TRUE}
#Correcting for type 1 error and multiple comparisons
#code from this post
#https://stats.stackexchange.com/questions/370724/indiscpecies-multipatt-and-overcoming-multi-comparrisons/401277#401277

# By Mimulus Species
#Extract table of stats
multipatt_analysis_sign <- as.data.table(multipatt_analysis$sign, keep.rownames=TRUE)

# #Add adjusted p-value
multipatt_analysis_sign[, p.adj := p.adjust(p.value, method = "BH")] #This can also be calculated with `dplyr` and `tidyr`
# #indval.table <- indval.sign |>
#   #mutate(p.value.bh = p.adjust(p.value, method = "BH"))
 
# #Now we can select only the indicators with adjusted significant p-values
multipatt_analysis_sign <- multipatt_analysis_sign[p.adj <= 0.06,]

#Renaming the first column
colnames(multipatt_analysis_sign)[1]  <- "ASV" 

# By Elevation
#Extract table of stats
multipatt_analysis_elev_sign <- as.data.table(multipatt_analysis_ele$sign, keep.rownames=TRUE)

# #Add adjusted p-value
multipatt_analysis_elev_sign[, p.adj := p.adjust(p.value, method = "BH")] #This can also be calculated with `dplyr` and `tidyr`
# #indval.table <- indval.sign |>
#   #mutate(p.value.bh = p.adjust(p.value, method = "BH"))
 
# #Now we can select only the indicators with adjusted significant p-values
multipatt_analysis_elev_sign <- multipatt_analysis_elev_sign[p.adj <= 0.06,]

#Renaming the first column
colnames(multipatt_analysis_sign)[1]  <- "ASV" 
```

No ASVs significantly correlated with Mimulus species. When we test for correlations in elevation categories and adjust the p value for multiple comparison we are left with only 0 ASVs.

NO evidence of a core ASV community associated with Mimulus or elevation types.
